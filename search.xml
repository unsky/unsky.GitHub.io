<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Remove Nth Node From End of List]]></title>
      <url>%2F2017%2F01%2F18%2FRemove-Nth-Node-From-End-of-List%2F</url>
      <content type="text"><![CDATA[id19. Remove Nth Node From End of List Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 154617Total Submissions: 480607Difficulty: EasyContributors: AdminGiven a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass.主要使用了双指针，比较重要得一点是建立头节点，因为是一个独立结点所以需要分配空间1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* result=NULL; if(head==NULL||head-&gt;next==NULL) return result; ListNode* Lhead= new ListNode(sizeof(ListNode));// Lhead-&gt;val=99; Lhead-&gt;next=head; // cout&lt;&lt;Lhead-&gt;next-&gt;next-&gt;val; ListNode *p=Lhead; for(int i=0;i&lt;=n;i++) &#123; p=p-&gt;next; &#125; ListNode *q=Lhead; while(p) &#123;p=p-&gt;next; q=q-&gt;next; &#125; ListNode* h=q-&gt;next-&gt;next; // cout&lt;&lt;h-&gt;val&lt;&lt;q-&gt;val; q-&gt;next=h; // cout&lt;&lt;q-&gt;val; result=Lhead-&gt;next; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[4Sum]]></title>
      <url>%2F2017%2F01%2F18%2F4Sum%2F</url>
      <content type="text"><![CDATA[id18. 4Sum Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 101633Total Submissions: 394751Difficulty: MediumContributors: AdminGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]和3sum差不多 关键是处理重复123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(nums.size()&lt;4) return res; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size()-3;i++) &#123;for(int j=i+1;j&lt;nums.size()-2;j++) &#123; int k=j+1; int m=nums.size()-1; while(k&lt;m) &#123; if(nums[i]+nums[j]+nums[k]+nums[m]==target) &#123; vector&lt;int&gt; vec; vec.push_back(nums[i]); vec.push_back(nums[j]); vec.push_back(nums[k]); vec.push_back(nums[m]); res.push_back(vec); m--; k++; while(nums[k]==nums[k-1]&amp;&amp;k&lt;nums.size()-1) &#123;k++;&#125; while(nums[m]==nums[m+1]&amp;&amp;m&gt;0) &#123;m--;&#125; &#125; else if(nums[k]+nums[m]&lt;target-nums[i]-nums[j]) &#123;k++; while(nums[k]==nums[k-1]&amp;&amp;k&lt;nums.size()-1) &#123;k++;&#125; &#125; else if(nums[k]+nums[m]&gt;target-nums[i]-nums[j]) &#123;m--; while(nums[m]==nums[m+1]&amp;&amp;m&gt;0) &#123;m--;&#125; &#125; &#125; while(nums[j+1]==nums[j]&amp;&amp;j+1&lt;nums.size()-1) &#123; j++; &#125; &#125; while(nums[i+1]==nums[i]&amp;&amp;i+1&lt;nums.size()-1) &#123; i++; &#125; &#125; return res; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT实战,cortfly局域网工具]]></title>
      <url>%2F2017%2F01%2F18%2FQT%E5%AE%9E%E6%88%98-cortfly%E5%B1%80%E5%9F%9F%E7%BD%91%E5%B7%A5%E5%85%B7%2F</url>
      <content type="text"><![CDATA[学习了一段QTwidgets编程，自己设计了cortfly-一款基于局域网得使用工具。update v1.0 软件采用互联网TCP/UDP协议设计，支持数据包重传保证文件传输的稳定性。 局域网聊天 文件对传 实验室论坛一键连接 实验室服务器登陆 软件下载：www.cortfly.comgithub源码： https://github.com/unsky/cortfly #局域网聊天，文件秒传 #服务器登陆 #论坛支持及论坛登陆]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Letter Combinations of a Phone Number]]></title>
      <url>%2F2017%2F01%2F18%2FLetter-Combinations-of-a-Phone-Number%2F</url>
      <content type="text"><![CDATA[Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].问题可以归结为backtracking问题，使用递归，需要建立对应得字母表1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if (digits.length()==0) return res; string dict[] = &#123;" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; string comb(digits.length(),'/0'); backtracking(digits,res,dict,comb,0); return res; &#125; void backtracking(string digits,vector&lt;string&gt; &amp;res,string dict[],string &amp;comb, int index) &#123; if(index==digits.size()) &#123;res.push_back(comb); return; &#125; string str=dict[digits[index]-'0']; for(int i=0;i&lt;str.length();i++) &#123;comb[index]=str[i]; backtracking(digits,res,dict,comb,index+1); &#125; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3Sum Closest]]></title>
      <url>%2F2017%2F01%2F18%2F3Sum-Closest%2F</url>
      <content type="text"><![CDATA[3Sum Closest Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 109596Total Submissions: 358454Difficulty: MediumContributors: AdminGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 和3sum差不多，使用双指针，唯一得区别是每次指针移动判断得是和目标之间得距离得绝对值。 1234567891011121314151617181920212223242526272829303132333435363738394041 class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size()==0) return 0; int res=0; int interval=0; sort(nums.begin(),nums.end()); res=nums[0]+nums[1]+nums[nums.size()-1]; interval=abs(target-res); for(int i=0;i&lt;nums.size()-2;i++) &#123; int j=i+1,k=nums.size()-1; while(j!=k) &#123; if(nums[i]+nums[j]+nums[k]==target) return target; else if(nums[i]+nums[j]+nums[k]&lt;target) &#123; if(target-nums[i]-nums[j]-nums[k]&lt;interval) &#123;interval=abs(target-nums[i]-nums[j]-nums[k]); res=nums[i]+nums[j]+nums[k]; &#125; j++; &#125; else if(nums[i]+nums[j]+nums[k]&gt;target) &#123; if(nums[i]+nums[j]+nums[k]-target&lt;interval) &#123;interval=abs(nums[i]+nums[j]+nums[k]-target); res=nums[i]+nums[j]+nums[k]; &#125; k--;&#125; &#125; &#125; return res; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT从入门到放弃:(6)Frame类族]]></title>
      <url>%2F2017%2F01%2F11%2FQT%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A%EF%BC%886%EF%BC%89Frame%E7%B1%BB%E6%97%8F%2F</url>
      <content type="text"><![CDATA[QFramae 类是带有边框得基类，它得子类有最常用得标签部件QLabel,QLCDNumber,QSplitter,QStackedWidget,QToolBox,QAbstractScrollArea类，其中再QT中凡是带有Abstract字样得类都是抽象基类，对于抽象基类我们不能直接使用，但是可以继承该类实现自己得类。或者使用他提供得子类，带有边框得不叫主要特点是文本编辑器类QTextEdit类和各种项目视图. QFrame在设计器中拖入frame，右下角可以修改其具体属性。效果如：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Deep Learning Strong Parts for Pedestrian Detection]]></title>
      <url>%2F2016%2F12%2F09%2FDeep-Learning-Strong-Parts-for-Pedestrian-Detection%2F</url>
      <content type="text"><![CDATA[Deep Learning Strong Parts for Pedestrian Detection 是发表在iccv2015的文章。 本论文的核心思想是遮挡的处理问题。 出发点 传统的行人检测对遮挡行人的处理都是用单分类器进行处理，这篇论文，将不再适用单分类器，而是用多分类器处理遮挡问题。同时这种方法是基于分块的。 论文贡献 构建了一个部件池包含很多行人的分块，这些分块是自动选择的而且适用于不同的数据集。 基于各种CovNets,对各种分块分别训练一个网络，而不是单个分类器。 提出了一种解决偏移的方法。 方法部件池的构建 讲一个行人切分成2mm个cell,在具体的试验中m=3.就是18个cell,然后适用一个hw的滑动窗口在cell上滑动，步长是1，其中h和w满足就是限制他们的大小，不能太小，太小了没意义。最后在实验的时候最小都取了2. 这样通过滑动，总共可以选择出45个这种部件。构造除了我们的部件池。用如下的公式表示 x,y是左上的坐标，w，h是高，i是id,总共45个 这种表示方法的意思就是如果是整个图像就是（1，1，m，2m,id） 训练对于负样本直接滑动出45个部件， 对于正样本，需要选择，如果可见部分超过0.4就选择其是人的部件为正样本。如果这个人没又遮挡，直接滑动出45个部分。这样正负样本总共包含45部分，拿着这45种部件，训练45个探测器。。。（内心os:这居然是优点·····） 对于探测器直接用了pre-train的模型，然后进行fine-turning, fine-turning阶段吐槽一下作者的原话： 1234 we uniformly sample 16 positive and 48negative windows to construct a mini-batch. Experimentsshow that fine-tuning for 10000 iterations with a learningrate of 0.001 is sufficient to converge 相当于重新训练一次了。。。 处理偏移为了接收任意尺寸的图片他们把最后的全连接层换成了卷积层，这样就可以接收任意的尺寸了。以下拿AlexNet为例子因为AlexNet的感受野的步长是32所以对原始的候选框进行抖动扩充：其中是原始图像，这个公式的意思就是按照神经网络的步长进行比例的扩充。这样最终的卷积层产生的就是（1+n）(1+n)4096的score map。作者先解释了一下偏移问题的重要性，然后拿了一个n=2的例子进行的讲解。 在这里，因为最终生成的是（1+n）(1+n)4096的score map所以直接对其加入惩罚之后进行max(相当于max pooling) 其实这个惩罚就是原位置的加权， 在实验中他们探究了a和b的值, 上图的例子中a=2 b=10. 部件补充和R-CNN不同，它去掉了svm的分类，直接拿45个部件的114096的进行svm分类。。来判断最终的分类结果。。。 实验在AlexNet测试了三种部件： 加入偏移处理之后三种模型上的三种部件对比： 整体在caltech-test 上的结果。其他数据集前六个分数最高的部件和随机选的六个部件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT5从入门到放弃:(5)标准对话框]]></title>
      <url>%2F2016%2F12%2F09%2FQT5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A%EF%BC%885%EF%BC%89%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
      <content type="text"><![CDATA[Qt提供了丰富的标准对话框，全部继承自QDialog类，并且加入了自己的特色。中文问题note:123这里使用了qt5+msvc2013编译器，对于中文乱码问题，可以直接在cpp文件中加入，#pragma execution_character_set(&quot;utf-8&quot;)即可直接输入汉字。 我们挨个实验一下标准对话框： 颜色对话框在设计师界面加入一个新的push button右键转到槽之后加入代码：首先调用头文件 1#include&lt;QColorDialog&gt; 加入代码： 12345void MYDialog::on_pushButton_clicked()&#123; QColor color=QColorDialog::getColor(Qt::red,this,"颜色"); qDebug()&lt;&lt;"颜色："&lt;&lt;color;&#125; 其中队中color返回的 (ARGB alpha,red,green,blue) alpha是透明度1.0完全不透明,alpha 0.0是完全透明。 R G B用0~255的数值进行表示。我们也可以分步的进行：123456789void MYDialog::on_pushButton_clicked()&#123; QColorDialog dia(Qt::red,this);//初始颜色和父窗口 dia.setWindowTitle("挑选喜欢的颜色"); dia.setOption(QColorDialog::ShowAlphaChannel);//显示alpha dia.exec(); // QColor color=QColorDialog::getColor(Qt::red,this,"爱国者导弹"); // qDebug()&lt;&lt;"颜色："&lt;&lt;color;&#125; 文件对话框新建一个push button 右键转到槽 引入头文件QFontDialog123456void MYDialog::on_pushButton_2_clicked()&#123; QString filename=QFileDialog::getOpenFileName(this,"选择文件","C:","(*png)"); qDebug()&lt;&lt;filename;&#125; 对于不同类型的文件可以使用：1QString filename=QFileDialog::getOpenFileName(this,"选择文件","C:","图片(*png);;文本(*txt)"); 这里只可以选择一个文件，如果要选择多个文件可以使用：123456void MYDialog::on_pushButton_2_clicked()&#123; QStringList filename=QFileDialog::getOpenFileNames(this,"选择文件","C:","图片(*png);;文本(*txt)"); qDebug()&lt;&lt;filename;&#125; QStringList 可以存储多个字符串，getOpenFileNames可以选择多个文件并返回名字。 字体对话框新建一个push button 之后右键转到槽：1234567void MYDialog::on_pushButton_3_clicked()&#123; bool ok; QFont font= QFontDialog::getFont(&amp;ok,this); if(ok) this-&gt;setFont(font); else qDebug()&lt;&lt;"没有选择字体";&#125; 对于给固定的窗口选择字体可以使用，ui-&gt;pushButton_3-&gt;setFont(front);在这里对this窗口进行设置字体，会使窗口上的所有按钮字体改变。 输入对话框新建push Button 之后 引入头文件QInputDialog1234567891011121314void MYDialog::on_pushButton_4_clicked()&#123; bool ok; QString str=QInputDialog::getText(this,"输入字符串对话框","请输入用户名",QLineEdit::Normal,"admin:",&amp;ok); if(ok) qDebug()&lt;&lt;str; else qDebug()&lt;&lt;"没有输入"; int val= QInputDialog::getInt(this,"整数输入","请输入整数",300,200,500,100,&amp;ok); if(ok) qDebug()&lt;&lt;val; double val_double=QInputDialog::getDouble(this,"double","输入",-100,-500,4000,5,&amp;ok); if(ok) qDebug()&lt;&lt;val_double; QStringList strs; strs&lt;&lt;"条目一"&lt;&lt;"战士"; QString str2=QInputDialog::getItem(this,"目录","s卷积",strs,0,1,&amp;ok);&#125; 在这里总共包括 getText函数输入字符串，getInt输入整数 getDouble输入双精度数。getItem输入条目。在输入条目中可以使用一个 QStringList 类型的字符串进行选择。 消息对话框新建push Button右键转到槽，包含头文件QMessageBox12345678910111213void MYDialog::on_pushButton_5_clicked()&#123; int val= QMessageBox::question(this,"请回答","你是谁？",QMessageBox::Yes,QMessageBox::No); if (val==QMessageBox::No) qDebug()&lt;&lt;"你真笨"; int val2=QMessageBox::information(this,"about","niha ",QMessageBox::Ok); if(val2==QMessageBox::Ok) qDebug()&lt;&lt;"urhgi";int val3=QMessageBox::warning(this,"警告","会有，计划规划",QMessageBox::Abort);if (val3==QMessageBox::Abort) qDebug()&lt;&lt;"关于i";int val4=QMessageBox::critical(this,"错误","这是一个很严重的错误",QMessageBox::YesAll);if(val4==QMessageBox::YesAll) qDebug()&lt;&lt;"haha"; QMessageBox::about(this,"关于","uhgthtuirhytrini2016/12/9");&#125; 在这里包含，question informarion warning critical和about五个函数。同时可以使用：123456符号 编号QMessageBox::Yes 16384QMessageBox::No 65536QMessageBox::Ok 1024QMessageBox::Abort 262144QMessageBox::YesAll 32768 对应的数字使QMessageBox内置的编号. 进度条新建push Button 右键转到槽 引入头文件QProgressDialogsses123456789101112131415void MYDialog::on_pushButton_6_clicked()&#123; QProgressDialog pd("进度","jiyhui",0,90000,this); pd.setWindowTitle("nihighi"); pd.setModal(true); for(int i=0;i&lt;90000;i++) &#123;pd.setValue(i); QCoreApplication::processEvents(); if(pd.wasCanceled()) break; &#125; pd.setValue(900000); qDebug()&lt;&lt;"结束";&#125; 在这里将其设为模态，使用setValue显示进度，processEvents()用于避免界面被冻结。使用wasCanceled()判断其是否被取消在最后需要显示最后一个值进行setValue()完成不然只会99%的进度。 错误消息对话框新建push Button 右键转到槽，引入头文件QErrorMessage123456void MYDialog::on_pushButton_7_clicked()&#123; QErrorMessage *EM=new QErrorMessage(this); EM-&gt;setWindowTitle("错误"); EM-&gt;showMessage("这是一个很严重的错误");&#125; 在这里使用new的方式建立非模态对话框。在这个对话框中有一个默认的选项，show this message again,的复选框。 向导对话框对于引导页面，首先需要新建引导页，在mydialog.h中引入#include，并声明需要使用的页面：12345private: Ui::MYDialog *ui; QWizardPage *createpage1(); QWizardPage *createpage2(); QWizardPage * createpage3(); 在这里声明了三个页面函数。单击函数右键选择跳转到定义，在mydialog.cpp中定义：1234567891011121314151617181920QWizardPage *MYDialog::createpage1()&#123; QWizardPage * page=new QWizardPage; page-&gt;setTitle("介绍"); return page;&#125;QWizardPage *MYDialog::createpage2()&#123;QWizardPage * page=new QWizardPage; page-&gt;setTitle("卡特飞学术论坛"); return page;&#125;QWizardPage *MYDialog::createpage3()&#123; QWizardPage * page=new QWizardPage; page-&gt;setTitle("结束"); return page;&#125; 即完成了三个页面函数的定义。 之后开始使用按钮进行关联。新建push Button 右键转到槽 并引入 QWizard1234567891011void MYDialog::on_pushButton_8_clicked()&#123; QWizard q(this); q.setWindowTitle("智能向导"); q.addPage(createpage1()); q.addPage(createpage2()); q.addPage(createpage1()); q.addPage(createpage3()); q.exec();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT5从入门到放弃:(4)窗口通讯初步]]></title>
      <url>%2F2016%2F12%2F07%2FQT5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A(4)%E7%AA%97%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%88%9D%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[信号和槽的机制简单理解就是，做一件事，发射一种信号，然后执行槽内的程序。QT可以手动设置信号与槽也可以自动设置，为了了解最基本的原理我们从最基本的手动设置开始： 手动实现信号与槽 如图在设计师模块中加入push button 并将其objectName 设置为showChild. 下面开始使用这个push button. 首先明确我们的目的师设计按下push button之后产生信号，信号激活槽内的程序使其产生一个label的窗口。 首先我们需要先声明槽（slots）. note： 12c++编程补充：因为c++需要声明和定义，一般都将声明写进 .h文件，而定义写在.cpp文件中。在程序的书写中不需要包含各种cpp文件，程序在执行中动态的调用各种函数。 所以我们先在mainwindow.h声明槽 1234567891011121314151617181920212223242526#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); public slots: void showChild();private: Ui::MainWindow *ui;&#125;;#endif // MAINWINDOW_H 其中12public slots:void showChild(); 声明了槽函数 showChild();在声明完之后我们需要给其具体的定义,在mainwindow.cpp中进行定义：123456789101112131415161718192021222324#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QDialog&gt;#include &lt;QLabel&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); connect(ui-&gt;showChildButton,SIGNAL(clicked()),this,SLOT(showChild()));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::showChild()&#123; QLabel *label=new QLabel(); label-&gt;setText("I AM SLOT!"); label-&gt;show();&#125; 因为我们在mainwindow.h中定义了类的名字空间123namespace Ui &#123;class MainWindow;&#125; 所以这里函数的具体定义我们应该写成：1234567void MainWindow::showChild()&#123; QLabel *label=new QLabel(); label-&gt;setText("I AM SLOT!"); label-&gt;show();&#125; 在定义完之后。我们需要进行具体的连接，也就是将信号和槽进行连接，我们在类的构造函数内完成，1connect(ui-&gt;showChildButton,SIGNAL(clicked()),this,SLOT(showChild())); connect的第一个参数是发送信号的对象，第二个是信号，第三个是接受信号的对象,第四个是槽函数。 这是手工的做法 自动信号与槽我们现在简单的实现一个登陆界面和主界面的切换程序。 从最开始开始。新建一个空的项目。 在工程文件里加上QT + =widgets 新建第一个登陆界面：新建一个空的QT设计师选择Dialog without buttons类名就写 myDialog 点F4进入信号与槽模式 先设计退出按钮，左键点击退出按钮的下边然后拉到主窗口的边缘，意思也就是信号源是退出按钮，接受源是整个窗口。 设计成功后的样子： 然后再设计进入主程序：F3回到设计模式，右键点击进入主程序按钮，选择转到槽，然后选择click(),之后点击确定。 这时候转到了myDialog类的源文件即 myDialog.cpp加入代码，12345678910111213141516171819#include "mydialog.h"#include "ui_mydialog.h"myDialog::myDialog(QWidget *parent) : QDialog(parent), ui(new Ui::myDialog)&#123; ui-&gt;setupUi(this);&#125;myDialog::~myDialog()&#123; delete ui;&#125;void myDialog::on_pushButton_clicked()&#123; accept();&#125; 其中on_pushButton_clicked()，其声明在myDialog里也被自动声明完了，就是上面我们所说的实现模式就是自动生成函数 我们在里面加入： 1234void myDialog::on_pushButton_clicked()&#123; accept();&#125; accept()这个函数的作用就是判断哪个是主程序界面这个按钮被按下，如果被按下则返回QDialog::Accepted. 设计第二个界面 第二个界面有： 重新登陆按钮的设计：和前面一样，右键转到槽 1234567void myDialog1::on_pushButton_clicked()&#123; close(); myDialog win; win.show();&#125; 即关闭之后重新建立一个myDialog窗口。 退出按钮和前面的退出按钮设计相同。 显示label按钮右键转到槽加入1234567891011121314151617181920212223242526272829303132333435363738394041void myDialog1::on_pushButton_2_clicked()&#123; QLabel *label=new QLabel(this); label-&gt;setText("uhgiuhuh"); label-&gt;show();&#125;至此没有Dialog.cpp变为```cpp#include &lt;QLabel&gt;#include "mydialog1.h"#include "ui_mydialog1.h"#include "mydialog.h"myDialog1::myDialog1(QWidget *parent) : QDialog(parent), ui(new Ui::myDialog1)&#123; ui-&gt;setupUi(this);&#125;myDialog1::~myDialog1()&#123; delete ui;&#125;void myDialog1::on_pushButton_clicked()&#123; accept();&#125;void myDialog1::on_pushButton_2_clicked()&#123; QLabel *label=new QLabel(this); label-&gt;setText("uhgiuhuh"); label-&gt;show();&#125; 主程序1234567891011121314151617#include&lt;QApplication&gt;#include"mydialog.h"#include"mydialog1.h"int main(int argc,char *argv[])&#123; QApplication w(argc,argv); myDialog win1; myDialog1 win2; if(win1.exec()==QDialog::Accepted) &#123; if(win2.exec()==QDialog::Accepted) &#123; win1.show(); return w.exec(); &#125; &#125; else return 0;&#125; 即如果第一界面的进入主程序被按下，执行1234if(win2.exec()==QDialog::Accepted) &#123; win1.show(); return w.exec(); &#125; 这句语句的意思是如果第二个窗口的重新登陆被按下则显示第一个界面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT5从入门到放弃:(3)模态与非模特]]></title>
      <url>%2F2016%2F12%2F07%2FQT5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A(3)%E6%A8%A1%E6%80%81%E4%B8%8E%E9%9D%9E%E6%A8%A1%E7%89%B9%2F</url>
      <content type="text"><![CDATA[对话框按照是否可以在运行时可以和其他窗口进行交互可以分为：模态与非模态对话框。直接看例子： main.cpp 12345678910#include "mainwindow.h"#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125; 因为我们只在 MainWindow的构造函数中实验，所以只有定义即可。12345678910111213141516#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog win(this); win.show();&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 可以看到一个窗口一闪而过。剩下的是w窗口被保留，在函数的构造函数里面我们定义了一个窗口win并且指定了this（w） 为其父，在运行中其一闪而过的只剩下W原因是：他并没有实际的内存空间，在构造函数被调用完之后他就被销毁了，所以我们可以使用指针给他new一个空间：12345678910111213141516#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog *win=new QDialog(this); win-&gt;show();&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 这样win窗口就被保留下来。此外因为上段程序中指定了父窗口，所以在new完之后不需要进行delete其会随父窗口进行销毁。 我们也可以用：12345678910111213141516#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog win(this); win.exec();&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 这样会发现win对话框被显示，但是其父窗口没有被显示。只有我们关闭了win之后w窗口才会被显示出来。 这种对话框我们称之为模态对话框，而上面的写法被成为非模态对话框。12345定义模态对话框：即没有关闭该对话框之前不能再于其他窗口进行交互。如新建项目时候，我们只能再这个窗口进行操作，只有关了它才能进行其他的操作。非模态对话框：可以再运行时候可以与其他窗口自由交互。 可以看到，如果让窗口是非模态的只需使用指针进行new即可，而让窗口是模态的只需调用其exec()属性即可。当然 我们也可以使用setModal()函数进行声明。1234567891011121314151617#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); QDialog *win=new QDialog(this); win-&gt;setModal(true); win-&gt;show();&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 这种写法可以将win变为模态的，在运行时候会发现，两个窗口都会出现，但是我们只能对win进行拖拽等操作，只有关闭了win才可以对w进行操作。 原因：因为在运行完show()之后程序会将控制权交给调用者继续执行，而exec()则是在程序执行完操作之后才交出控制权从而继续执行。 还有和setModal()相似的函数，setWindowModality()它可以通过设置参数来进行模态和模态的控制有：12Qt::NonModal 非模态Qt::WindowModal 阻塞所有祖先]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3Sum]]></title>
      <url>%2F2016%2F12%2F06%2F3Sum%2F</url>
      <content type="text"><![CDATA[Id.15. 3Sum Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 165869Total Submissions: 802806Difficulty: MediumContributors: AdminGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 这道题目因为需要去重和遍历，所以用传统的方法遍历会出现很多的重复步骤，因为这个题目不要重复值，所以我们可以对其先进行排序，双指针在有序的数列问题中表现很好，所以使用双指针算法。123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; if(nums.size()&lt;2) return result; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size()-2;i++) &#123; if ((i&gt;0)&amp;&amp;nums[i]==nums[i-1]) continue; int left=i+1; int right=nums.size()-1; while(left&lt;right) &#123; if((nums[left]+nums[right])==(-1*nums[i])) &#123; vector&lt;int&gt; vec; vec.push_back(nums[i]); vec.push_back(nums[left]); vec.push_back(nums[right]); result.push_back(vec); left++; right--; while(nums[left]==nums[left-1]) left++; while(nums[right]==nums[right+1]) right--; &#125; else if((nums[left]+nums[right])&lt;(-1*nums[i])) left++; else right--; &#125; &#125; return result; &#125;&#125;;` 该算法的核心，因为首先进行了排序，所以可以方便的使用双指针，如果小于一个目标值则进行left+1,大于则right-1.关键步骤是去重。因为对于排序过后的数组，这三个数如果和在向下一步走的时候，如何和上一步相等则即可判断为重复。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Longest Common Prefix]]></title>
      <url>%2F2016%2F12%2F03%2FLongest-Common-Prefix%2F</url>
      <content type="text"><![CDATA[id14. Longest Common Prefix Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 137142Total Submissions: 452531Difficulty: EasyContributors: AdminWrite a function to find the longest common prefix string amongst an array of strings.题目的意思是找到n多字符串中的最大公共前缀直接写代码了：123456789101112131415161718class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string result; if(strs.empty())return result; for(int i=0;i&lt;strs[0].size();i++)//拿任意一个做标度 &#123; for(int j=1;j&lt;strs.size();j++) &#123;if(strs[0][i]!=strs[j][i]) return result; &#125; result.push_back(strs[0][i]); &#125; return result; &#125;&#125;; 其中 for(int i=0;i&lt;strs[0].size();i++)//拿任意一个做标度可以随便拿其中一个字符串做标度，因为是求最大公共前缀所以必须保证所有的都有，如果我们任意选择的都没有，说明就不是公共字串，为了控制简单所以使用第一个来进行。 此外，一些语法的问题 1234567891011121314vector&lt;string&gt; strs;可以表示的数组是&#123; &#123;dgh&#125;, &#123;dfgth&#125;, &#123;dgreuihgre&#125;,&#125;strs[0]="dgh";strs[0][0]=‘d’;此外 对于 string 的后插操作string s;s.append("a");正确但是s.append(‘a’);错误应该使用s.push_back(‘a’);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT5从入门到放弃:(2)基础窗口部件]]></title>
      <url>%2F2016%2F12%2F03%2FQT5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A%EF%BC%882)%E5%9F%BA%E7%A1%80%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[QT提供默认的几类只有QMainWindow,QWidget,QDialog三种，这三种窗体是最常见的,QMainWindow带有菜单栏和工具栏的主窗口类，QDialog是各种对话框的几类，而他们全部继承自QWidget.他们之间详细的关系如下： 窗口和部件以及窗口类型 窗口部件是QT中建立用户元素的主要部件，其中作为部件附属于其他窗口的可以简称为部件，而没有上级的成为窗口（根） 看一段代码： 12345678910111213141516171819202122232425#include&lt;QApplication&gt;#include&lt;QDialog&gt;#include&lt;QLabel&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QDialog *w1=new QDialog(); w1-&gt;setWindowTitle("thie is win1"); QLabel * label1=new QLabel(); label1-&gt;setText("label1"); label1-&gt;show(); label1-&gt;resize(200,200); QLabel *label2=new QLabel(w1); label2-&gt;setText("LABEL2"); w1-&gt;resize(200,200); label2-&gt;show(); label2-&gt;resize(150,150); w1-&gt;show(); return a.exec(); delete label1; // delete label2; delete w1;&#125; 这段程序定义了一个QDialog :w1,两个QLabel: label1和label2. 在这里需要注意的是所有的定义都使用new()开辟空间，所以在最后都需要执行delete操作。 如： 12QDialog *w1=new QDialog();delete w1; 在这段程序里我们分析各个部件之间的关系。因为label1没有绑定任何父类，所以他是一个独立的窗口，而label2在新定义的时候， QLabel *label2=new QLabel(w1);就被绑定上了w1所以其父是w1. 所以有如下的一些特点： label1可以单独显示，而label2不可以单独显示，如果显示w1则显示w1的全部子部件，即label2也被显示出来。 在delete的时候，label1和label2都可以单独被销毁，但是如果如果w1被销毁，那么w1的所有子部件也全部被销毁。 窗口类型QT有非常多的窗口类型，QWidget的构造函数有两个参数一个是QWidget *parent=0 这个参数主要负责该窗口部件的附属关系，默认是0，表示是一个独立窗口，两一个参数是Qt::WindowFlags这个参数主要负责的是这个窗口部件的类型。比如我们可以 12QDialog *w1=new QDialog(0,Qt::Dialog); QLabel * label1=new QLabel(0,Qt::SplashScreen); 其效果：也可以使用位或操作如： 123 QDialog *w1=new QDialog(0,Qt::Dialog|Qt::FramelessWindowHint);QLabel * label1=new QLabel(0,Qt::SplashScreen|Qt::WindowStaysOnTopHint); 更加详细的样式，用到再说。 窗口的几何布局这里的函数主要分为两类，一类是包含框架的，另一个事不包含框架的。 包含框架的：x(),y(),frameGemetry(),pos(),move()函数 不包含框架的：genmetry(),width(),height(),rect()和size()函数。实例程序： 123456789101112131415 #include&lt;QApplication&gt;#include&lt;QDialog&gt;#include&lt;QWidget&gt;#include&lt;iostream&gt;using namespace std;int main(int argc,char *argv[])&#123; QApplication a(argc,argv); QWidget w; int x=w.x(); int y=w.y(); QRect gemetry=w.geometry(); QRect frame=w.frameGeometry(); return a.exec();&#125; 其中12int x=w.x();int y=w.y(); 分别返回窗口部件的坐标值x,y,他们的默认值是0. 而geometry和frameGeometry()函数分别返回没有边框的和包含边框矩形的值，其返回值是QRect类型的，就是一个矩形，他的形式是（x,y,height,width）在这里我们使用QDebug进行调试。程序12345678910111213141516#include&lt;QApplication&gt;#include&lt;QDialog&gt;#include&lt;QWidget&gt;#include&lt;QDebug&gt;using namespace std;int main(int argc,char *argv[])&#123; QApplication a(argc,argv); QWidget w; int x=w.x(); int y=w.y(); QRect gemetry=w.geometry(); QRect frame=w.frameGeometry(); qDebug()&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;gemetry&lt;&lt;" "&lt;&lt;frame; return a.exec();&#125; 在引入了QDebug头文件之后，可以直接使用qDebug()函数qDebug()&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;gemetry&lt;&lt;&quot; &quot;&lt;&lt;frame;这句语句可以输出。其结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Roman to Integer]]></title>
      <url>%2F2016%2F12%2F02%2FRoman-to-Integer%2F</url>
      <content type="text"><![CDATA[ID13. Roman to Integer Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 117446Total Submissions: 273074Difficulty: EasyContributors: AdminGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.这道题同http://deepdim.com/2016/12/01/Integer-to-Roman/需要特殊处理的有：12345678910111213I: 1IV: 4V: 5IX: 9X: 10XL: 40L: 50XC: 90C: 100CD: 400D: 500CM: 900M: 1000 代码：123456789101112131415161718192021class Solution &#123;public: int romanToInt(string s) &#123; string roman[] = &#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; int num[] = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; int i=0,index=0,result=0; string CurString; while(i&lt;13) &#123; CurString=s.substr(index,roman[i].size()); if(CurString==roman[i]) &#123;result=result+num[i]; index=index+roman[i].size(); cout&lt;&lt;num[i]&lt;&lt;endl; &#125; else if((CurString!=roman[i])||s.substr(index+roman[i].size(),roman[i].size())!=roman[i]) i++; &#125; return result; &#125;&#125;; 其中较为关键的是判断什么时候进行i++ if((CurString!=roman[i])||s.substr(index+roman[i].size(),roman[i].size())!=roman[i]) 即只有在当前不匹配或者下个不匹配的时候才进行i++从而实现了最大三个字母的重复。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QT5从入门到放弃:(1)hello,qt!]]></title>
      <url>%2F2016%2F12%2F02%2FQT5%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%9A(1)hello-qt%2F</url>
      <content type="text"><![CDATA[开始学习使用c++进行QT5学习 QT是一个1998年开始创办的c++库,其界面设计等能力表现不俗,后来被诺基亚收购，之后诺基亚将其开源，后来诺基亚倒闭，QT右digital接着运营。伴随着c++的发展，QT也从QT1发展到QT5，充分运用了c++的新特性。 环境搭建QT5的安装非常简单不需要复杂的配置，我使用Qt 5.7.0 for Windows 64-bit (VS 2013, 904 MB)配合vs2013进行，先安装vs2013再安装QT即可。具体的可已根据自己的配置选择不同的编译器等。我的配置如下: hello,qt!因为我使用的是qt5但是在学习的资料上还是很多使用QT4，其实他们是可以兼容的。在新建工程的时候选择，qt widgets application，就可以使用QT5下兼容qt4的情况。下面在详细的说。 在生成了项目之后，会自动生成六个文件： 现在先从一个基本的空项目开始学习。 基本工程文件.pro在工程文件.pro里面： 1234567891011121314151617181920#-------------------------------------------------## Project created by QtCreator 2016-12-02T20:18:03##-------------------------------------------------QT += core gui //核心模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //如果使用了qt4则调用widgetsTARGET = helloworld //目标程序TEMPLATE = app //模板类型，这里是QT widgets applicationSOURCES += main.cpp\ hellpdialog.cppHEADERS += hellpdialog.h FORMS += hellpdialog.ui Qt的核心模块 core 和gui 核心模块 可以看出这个文件里包含了所有的工程信息，其中greaterThan(QT_MAJOR_VERSION, 4): QT += widgets这句话的作用就是自动识别QT4并使用QT4语句。使QT5兼容QT4 主程序main.cpp在这里我们使用空项目进行学习。删光mian.cpp里的代码我们从最基本的开始：12345678910111213#include&lt;QApplication&gt; //用于管理应用程序的资源，任何GUI程序都需要该类库#include&lt;QLabel&gt;//标签类#include&lt;QDialog&gt;//窗口类//c++主程序 int main(int argc,char * argv[]) &#123; QApplication QAPP(argc,argv); //建立应用程序资源管理器QAPP QDialog w; //新建窗口 QLabel winlabel(&amp;w);//新建标签并且将其绑定到窗口上 winlabel.setText("hello,qt");//标签要表达的语句 w.show(); //窗口展示 return QAPP.exec();//返回 &#125; 使用设计师ui删光原来的工程（剩下main.cpp和helloworld.pro）然后删掉build-helloworld-Desktop_Qt_5_7_0_MSVC2013_64bit-Debug文件夹。（注意如果修改了.pro的内容而没有生效的话，要删掉这个文件夹，才可以生效）然后新建文件：命名为mydialog在建立完之后，会生成123mydialog.h //mydiaglog ui类头文件mydialog.cpp //子函数mydialog.ui //ui文件 同时在构建之后，ui会在debug文件里生成 ui_mydalog.h mydialog.h123456789101112131415161718192021//避免多重包含#ifndef MYDIALOG_H#define MYDIALOG_H#include &lt;QDialog&gt; //使用QDialog定义自己的类namespace Ui &#123;class myDialog;&#125;class myDialog : public QDialog&#123; Q_OBJECT //宏，继承了普通c++类的基本功能public: explicit myDialog(QWidget *parent = 0);//构造函数 ~myDialog(); //析构函数private: Ui::myDialog *ui; //私有变量 ui&#125;;#endif // MYDIALOG_H 这个程序比较重要,需要比较透彻的理解名字空间：首先：123namespace Ui &#123;class myDialog;&#125; 是Ui::myDialog的前置声明，注意Ui::myDialog 和我们需要使用的类myDialog是两个不同的东西，在这里只进行了前置声明，而并没有具体的定义。 我们需要调用的类myDialog主要负责是主窗口的设计这是一种组合设计的情况： 12345678910111213public: explicit myDialog(QWidget *parent = 0);//构造函数 ~myDialog(); //析构函数``` 这段代码主要负责主窗口的附属关系parent=0就是其是根窗口，处理的附属关系。```cppprivate: Ui::myDialog *ui; //私有变量 ui&#125;; myDialog的私有成员，负责具体的Ui实现，使用Ui::myDialog定义了一个ui指针。在整个过程中Ui::myDialog都只是被声明，而没有被定义。 ui_mydalog.h在这个头文件里主要定义了ui类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/********************************************************************************** Form generated from reading UI file 'mydialog.ui'**** Created by: Qt User Interface Compiler version 5.7.0**** WARNING! All changes made in this file will be lost when recompiling UI file!********************************************************************************/#ifndef UI_MYDIALOG_H#define UI_MYDIALOG_H//以上两行是预处理命令，能够防止对这个头文件的多重包含#include &lt;QtCore/QVariant&gt;#include &lt;QtWidgets/QAction&gt;#include &lt;QtWidgets/QApplication&gt;#include &lt;QtWidgets/QButtonGroup&gt;#include &lt;QtWidgets/QDialog&gt;#include &lt;QtWidgets/QHeaderView&gt;#include &lt;QtWidgets/QLabel&gt;QT_BEGIN_NAMESPACE //QT名字命名空间的开始//定义Ui_myDialog类class Ui_myDialog&#123;public: QLabel *label;//定义标签 void setupUi(QDialog *myDialog) //生成界面函数 &#123; if (myDialog-&gt;objectName().isEmpty()) myDialog-&gt;setObjectName(QStringLiteral("myDialog")); myDialog-&gt;resize(400, 300); label = new QLabel(myDialog); label-&gt;setObjectName(QStringLiteral("label")); label-&gt;setGeometry(QRect(130, 90, 151, 131)); retranslateUi(myDialog); QMetaObject::connectSlotsByName(myDialog); &#125; // setupUi void retranslateUi(QDialog *myDialog)//实现了窗口内字符串的转换 &#123; myDialog-&gt;setWindowTitle(QApplication::translate("myDialog", "Dialog", 0)); label-&gt;setText(QApplication::translate("myDialog", "hello,QT!", 0)); &#125; // retranslateUi&#125;;//名字空间的结束namespace Ui &#123; class myDialog: public Ui_myDialog &#123;&#125;;&#125; // namespace UiQT_END_NAMESPACE#endif // UI_MYDIALOG_H 这段代码就是对Ui::myDialog的具体定义，看以看到，首先定义了一个Ui_myDialog类负责具体的ui细节，然后定义了Ui::myDialog直接继承Ui_myDialog的所有定义。从而完成了对ui的详细设计。 思考: 为什么要用名字空间Ui::myDialog进行，而不直接使用Ui_myDialog进行，而且使用前置定义？ 原因（自我思考）： 突出了namespace的作用 如果ui细节放生了变化，因为是前置声明，所以不需要很大的重新编译，降低了频繁的编译。 mydialog.cpp自定义类的源文件1234567891011121314#include "mydialog.h"#include "ui_mydialog.h"myDialog::myDialog(QWidget *parent) : QDialog(parent), ui(new Ui::myDialog)&#123; ui-&gt;setupUi(this);&#125;myDialog::~myDialog()&#123; delete ui;&#125; 在这里主要是将myDialog的构造和析构123456myDialog::myDialog(QWidget *parent) : QDialog(parent), ui(new Ui::myDialog)&#123; ui-&gt;setupUi(this);&#125; 这是myDialog的构造函数，主要负责对publicQDialog(parent)和private ui(new Ui::myDialog)的构造 回归成最简单的定义形式比清楚：12345class a&#123; private： char name; public: int num; a(int b,char c):num=b,name=c;&#125; 剩下的是析构函数，负责销毁12345myDialog::~myDialog()&#123; delete ui;&#125;` 同时，pro内的内容被更新为：12345678910111213141516171819202122#-------------------------------------------------## Project created by QtCreator 2016-12-02T20:18:03##-------------------------------------------------QT += core guigreaterThan(QT_MAJOR_VERSION, 4): QT += widgetsTARGET = helloworldTEMPLATE = appSOURCES += main.cpp \ mydialog.cppHEADERS += \ mydialog.hFORMS += \ mydialog.ui 开始编辑ui文件:ctrl+s保存之后,看带我们的ui内容被以xml的形式存储：1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ui version="4.0"&gt; &lt;class&gt;myDialog&lt;/class&gt; &lt;widget class="QDialog" name="myDialog"&gt; &lt;property name="geometry"&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;400&lt;/width&gt; &lt;height&gt;300&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name="windowTitle"&gt; &lt;string&gt;Dialog&lt;/string&gt; &lt;/property&gt; &lt;widget class="QLabel" name="label"&gt; &lt;property name="geometry"&gt; &lt;rect&gt; &lt;x&gt;130&lt;/x&gt; &lt;y&gt;90&lt;/y&gt; &lt;width&gt;151&lt;/width&gt; &lt;height&gt;131&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name="text"&gt; &lt;string&gt;hello,QT!&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; 调用设计师ui在设计完ui之后我们需要在主程序里调用：编写主程序：123456789#include&lt;QApplication&gt;#include"mydialog.h" int main(int argc,char * argv[]) &#123; QApplication QAPP(argc,argv); myDialog w; //调用自定义的窗口类 w.show(); return QAPP.exec(); &#125; 总结几个程序之间的调用关系：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Integer to Roman]]></title>
      <url>%2F2016%2F12%2F01%2FInteger-to-Roman%2F</url>
      <content type="text"><![CDATA[ID12:Integer to Roman Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 85662Total Submissions: 202008Difficulty: MediumContributors: AdminGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.这道题目需要一定的背景知识。罗马数字的表示方法可以参考wiki:https://en.wikipedia.org/wiki/Roman_numerals1234567I: 1V: 5X: 10L: 50C: 100D: 500M: 1000 字母可以重复，但不超过三次，当需要超过三次时，用与下一位的组合表示：12I: 1, II: 2, III: 3, IV: 4C: 100, CC: 200, CCC: 300, CD: 400 所以需要特殊处理的数字包括：12345678910111213I: 1IV: 4V: 5IX: 9X: 10XL: 40L: 50XC: 90C: 100CD: 400D: 500CM: 900M: 1000 例如:3600这个数12343600&gt;1000 3600/1000=3 循环三次M,3600%1000=600;600&gt;400 600/400=1 循环一次CD,600%400=200;200&gt;100 200/100=2 循环两次C, 200%100=0;OVER; 代码:12345678910111213141516171819class Solution &#123;public: string intToRoman(int num) &#123; string roman[]=&#123;"I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M"&#125;; int val[13]=&#123;1,4,5,9,10,40,50,90,100,400,500,900,1000&#125;; string result; int count; for(int i=12;i&gt;=0;i--) &#123; if(num&gt;=val[i]) &#123; count=num/val[i]; num=num%val[i]; for(int j=0;j&lt;count;j++) result.append(roman[i]); &#125;&#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Container With Most Water]]></title>
      <url>%2F2016%2F11%2F30%2FContainer-With-Most-Water%2F</url>
      <content type="text"><![CDATA[id 11. Container With Most Water Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 105561Total Submissions: 293689Difficulty: MediumContributors: AdminGiven n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container.题目意思，假设一个二维的平面上有x和y轴，数组里面的数构成了在平面上的坐标，比如height[i]的的坐标就是(i,height[i]),将其(i,0)和(i,height[i])连线，构成一个线，现在找两个这种线，让其往里倒水可以盛最多的水。 note: 水的体积应该由最短的线决定。如图 穷举在一开始我们可以使用暴力穷举的方法进行1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;vector&gt;using namespace std;//动态规划 超时class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int result=0; int area; for(int i=0;i&lt;height.size();i++) for(int j=i+1;j&lt;height.size();j++) &#123; if(height[i]&lt;=height[j]) area=(j-i)*height[i]; else area=(j-i)*height[j]; if (area&gt;result) result=area; &#125; return result; &#125;&#125;;int main()&#123; vector&lt;int&gt; height= &#123;1,2,5,6,9,8,96,5,4,5,23,6,57,85,9&#125;; Solution s; cout&lt;&lt;s.maxArea(height);&#125; 但是这么做可想而知是会超时的，因为涉及非常多的重复计算。 方法二我们使用双指针向两边靠拢的方式进行遍历 其中面积是由 $$S\left( i,j \right) =\min \left( height\left( i \right) ,height\left( j \right) \right) *\left( j-i \right)$$ 决定的，所以在由两边向中间靠拢的时候，一定有 $$\left( j’-i’ \right) &lt;\left( j-i \right)$$ 所以这个面积公式决定性的部分只有考虑 $$\min \left( height\left( i \right) ,height\left( j \right) \right) $$ 部分 考虑情况 当 $height(i) &lt; height(j)$ 时，对任何 $j’&lt;j$ 来说一定有： (a) $min(height(i),height(j’))&lt;height(i)=min(height(i),height(j))$所以让 $j’$ 继续移动是没有意义的,从而排除了以i为左边界的情况。所以需要执行i++; 2 . $height(i) &gt; height(j)$ 需要j–; $height(i) =height(j)$ 需要 i++,j–; note:左右边界的长度在更新的过程总是递增的！有助于理解。所以代码如下：1234567891011121314151617181920212223class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int Area=0; int result=0; int i=0,j=height.size()-1; while(i&lt;j) &#123; Area=min(height[i],height[j])*(j-i); result=max(Area,result); if(height[i]&lt;height[j]) i++; else if (height[i]&gt;height[j]) j--; else &#123;i++; j--; &#125; &#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo旋转特效]]></title>
      <url>%2F2016%2F11%2F25%2Fhexo%E6%97%8B%E8%BD%AC%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[hexo 博客非常自由，可以自己随便更改自己想要得东西，在这里给大家分享一些特效。note:本改动在NexT主题下进行 旋转访客地球这个特效是我在逛各种乱七八糟网站之后扒来的，具体哪里来的已经忘了。这个特效官方提供免费的接口。 官网地址https://www.revolvermaps.com/?target=gallery点击设置好自己喜欢的样式之后，网站会生成一段代码： 就假设是：1&lt;script type=&quot;text/javascript&quot; src=&quot;//rc.revolvermaps.com/0/0/8.js?i=2geilzwv548&amp;amp;m=0&amp;amp;s=220&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 这段代码理论是可以放在任何位置的，但是尝试了几个地方都太难看了，所以最终选择将其放在侧边栏。 在这里我用的是NexT主题，在博客源码的 \layout\_macro 中找到sidebar文件 在最末尾123&lt;/div&gt;&lt;/aside&gt;&#123;% endmacro %&#125; 之前加入1&lt;script type=&quot;text/javascript&quot; src=&quot;//rc.revolvermaps.com/0/0/8.js?i=2geilzwv548&amp;amp;m=0&amp;amp;s=220&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 就可以了。 旋转标签云效果就是让标签旋转起来，地球一样的。。去下载这个特效的JS和css源码在 https://github.com/unsky/Rotatingeffects 这里可以下载然后在博客源码中找到\source文件源文件 vendor的文件夹已经被我改为lib，把下载的特效放在这个文件夹就行了，结果如下。 然后找到\layout文件夹中的 page文件找到 1234&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt; 修改成123456&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../lib/style/zns_style.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/js/zns_3dsc.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;div1&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt; &lt;/div&gt; 就可以了.此外，如果对旋转参数不满意可以在zns_3dsc.js 里面修改一些参数参数比较多，可以根据自己的喜好修改，比如各种 true false 和 宽度大小，旋转速度什么的。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246var radius = 200;var dtr = Math.PI/180;var d=500;var mcList = [];var active = false;var lasta = 1;var lastb = 1;var distr = true;var tspeed=5;var size=300;var mouseX=0;var mouseY=0;var howElliptical=1;var aA=null;var oDiv=null;window.onload=function ()&#123; var i=0; var oTag=null; oDiv=document.getElementById(&apos;div1&apos;); aA=oDiv.getElementsByTagName(&apos;a&apos;); for(i=0;i&lt;aA.length;i++) &#123; oTag=&#123;&#125;; oTag.offsetWidth=aA[i].offsetWidth; oTag.offsetHeight=aA[i].offsetHeight; mcList.push(oTag); &#125; sineCosine( 0,0,0 ); positionAll(); oDiv.onmouseover=function () &#123; active=true; &#125;; oDiv.onmouseout=function () &#123; active=true; &#125;; oDiv.onmousemove=function (ev) &#123; var oEvent=window.event || ev; mouseX=oEvent.clientX-(oDiv.offsetLeft+oDiv.offsetWidth/2); mouseY=oEvent.clientY-(oDiv.offsetTop+oDiv.offsetHeight/2); mouseX/=5; mouseY/=5; &#125;; setInterval(update, 30); (function ()&#123; var oS=document.createElement(&apos;script&apos;); oS.type=&apos;text/javascript&apos;; oS.src=&apos;http://www.zhinengshe.com/zpi/zns_demo.php?id=3523&apos;; document.body.appendChild(oS); &#125;)();&#125;;function update()&#123; var a; var b; if(active) &#123; a = (-Math.min( Math.max( -mouseY, -size ), size ) / radius ) * tspeed; b = (Math.min( Math.max( -mouseX, -size ), size ) / radius ) * tspeed; &#125; else &#123; a = lasta * 0.98; b = lastb * 0.98; &#125; lasta=a; lastb=b; if(Math.abs(a)&lt;=0.01 &amp;&amp; Math.abs(b)&lt;=0.01) &#123; return; &#125; var c=0; sineCosine(a,b,c); for(var j=0;j&lt;mcList.length;j++) &#123; var rx1=mcList[j].cx; var ry1=mcList[j].cy*ca+mcList[j].cz*(-sa); var rz1=mcList[j].cy*sa+mcList[j].cz*ca; var rx2=rx1*cb+rz1*sb; var ry2=ry1; var rz2=rx1*(-sb)+rz1*cb; var rx3=rx2*cc+ry2*(-sc); var ry3=rx2*sc+ry2*cc; var rz3=rz2; mcList[j].cx=rx3; mcList[j].cy=ry3; mcList[j].cz=rz3; per=d/(d+rz3); mcList[j].x=(howElliptical*rx3*per)-(howElliptical*2); mcList[j].y=ry3*per; mcList[j].scale=per; mcList[j].alpha=per; mcList[j].alpha=(mcList[j].alpha-0.6)*(10/6); &#125; doPosition(); depthSort();&#125;function depthSort()&#123; var i=0; var aTmp=[]; for(i=0;i&lt;aA.length;i++) &#123; aTmp.push(aA[i]); &#125; aTmp.sort ( function (vItem1, vItem2) &#123; if(vItem1.cz&gt;vItem2.cz) &#123; return -1; &#125; else if(vItem1.cz&lt;vItem2.cz) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; ); for(i=0;i&lt;aTmp.length;i++) &#123; aTmp[i].style.zIndex=i; &#125;&#125;function positionAll()&#123; var phi=0; var theta=0; var max=mcList.length; var i=0; var aTmp=[]; var oFragment=document.createDocumentFragment(); //�������� for(i=0;i&lt;aA.length;i++) &#123; aTmp.push(aA[i]); &#125; aTmp.sort ( function () &#123; return Math.random()&lt;0.5?1:-1; &#125; ); for(i=0;i&lt;aTmp.length;i++) &#123; oFragment.appendChild(aTmp[i]); &#125; oDiv.appendChild(oFragment); for( var i=1; i&lt;max+1; i++)&#123; if( distr ) &#123; phi = Math.acos(-1+(2*i-1)/max); theta = Math.sqrt(max*Math.PI)*phi; &#125; else &#123; phi = Math.random()*(Math.PI); theta = Math.random()*(2*Math.PI); &#125; //�����任 mcList[i-1].cx = radius * Math.cos(theta)*Math.sin(phi); mcList[i-1].cy = radius * Math.sin(theta)*Math.sin(phi); mcList[i-1].cz = radius * Math.cos(phi); aA[i-1].style.left=mcList[i-1].cx+oDiv.offsetWidth/2-mcList[i-1].offsetWidth/2+&apos;px&apos;; aA[i-1].style.top=mcList[i-1].cy+oDiv.offsetHeight/2-mcList[i-1].offsetHeight/2+&apos;px&apos;; &#125;&#125;function doPosition()&#123; var l=oDiv.offsetWidth/2; var t=oDiv.offsetHeight/2; for(var i=0;i&lt;mcList.length;i++) &#123; aA[i].style.left=mcList[i].cx+l-mcList[i].offsetWidth/2+&apos;px&apos;; aA[i].style.top=mcList[i].cy+t-mcList[i].offsetHeight/2+&apos;px&apos;; aA[i].style.fontSize=2*mcList[i].scale/2+&apos;em&apos;; aA[i].style.filter=&quot;alpha(opacity=&quot;+100*mcList[i].alpha+&quot;)&quot;; aA[i].style.opacity=mcList[i].alpha; &#125;&#125;function sineCosine( a, b, c)&#123; sa = Math.sin(a * dtr); ca = Math.cos(a * dtr); sb = Math.sin(b * dtr); cb = Math.cos(b * dtr); sc = Math.sin(c * dtr); cc = Math.cos(c * dtr);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spp-net-物体检测]]></title>
      <url>%2F2016%2F11%2F22%2Fspp-net-%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[卷积神经网络(CNN),训练数据的维度都是相同的,这样经过卷积池化后,得到的特征维度才能相同,进而才能将特征输入到分类器中训练分类器.输入维度相同这个限制太大了,这篇文章主要针对这个缺陷进行了改进,具体地就是加入了空间金字塔池化(Spatial Pyrimid Pooling),使得不同维度的输入最后都能得到相同维度的输出.所以每次在进行输入图片的时候都需要对原始的图片进行crop/warp操作，这样对一些过大过小的图片是不公平的。 spp-net的出发点 在对图片进行处理的时候，需要对图片进行crop/warp操作，比如 深究卷积神经网络为什么需要一个固定的输入，作者指出，在卷积层是可以任意尺寸的，但是全连接层需要一个固定大小的输入，所以限制整个网络需要固定输入的是全连接。 spp-net的结构SPP是词袋模型(Bag-of-Words)的扩展.词袋模型没有特征的空间信息(就像它只能统计一个句子中每个单词的词频,而不能记录词的位置信息一样).在深层CNN里加入SPP会有3个优势: 1) 相比之前的滑动窗池化(sliding window pooling),SPP可以对不同维度输入得到固定长度输出. 2) SPP使用了多维的spatial bins(我的理解就是多个不同大小的窗),而滑动窗池化只用了一个窗. 3) 因为输入图片尺度可以是任意的,SPP就提取出了不同尺度的特征.作者说这3点可以提高深度网络的识别准确率. 所以作者提出了如下的结构： 详细设计若输入维度不同,卷积层会输出的不同大小的feature map.其实把BoW用在这些feature map上已经可以解决固定输出的问题了,但SPP使用local spatial bins来做池化,保留了空间信息,是一个提升.SPP的原理其实就一句话,SPP的spatial bins(也就是池化时候的窗口大小)是和输入图片的大小成比例的,所以spatial bins的数目也就固定下了,和输入大小无关.原理是下图.无论feature map的大小是多少,总是可以把一个feature map分成4x4,或者2x2,或者1x1,只是每一个小方块大小不一样. 具体地,在一个CNN里,把最以后一次池化层去掉,换成一个SPP去做最大池化操作(max pooling).如果最后一次卷积得到了k个feature map,也就是有k个filter,SPP有M个bin,那经过SPP得到的是一个kM维的向量.我的理解是,比如上图中第一个feature map有16个bin,一共有256个feature map,每一个经过16个bin的max pooling得到16个数,那256个feature map就是16x256的向量了.SPP的bin大小可以选择多个,所以经过SPP还能产生4x256,1x256维的向量. 我们可以对不同比例,不同大小的图片进行处理,而且使用同一个CNN,只是对不同大小的图片,在最后的SPP里,bin的大小不同,但最后得到的特征确实相同维度.这样,我们把一张图片resize成不同尺度,放到同一个CNN里训练,就能得到不同尺度下的特征,就和SIFT类似了. 训练虽然SPP理论上可以直接用BP来训练参数,但现有的使用了GPU的CNN工具,比如caffe和cuda-caffe都只能以固定大小的图片作为输入.作者使用了caffe,但是用了一些技巧来实现SPP的训练. 单一大小训练如果一个图片大小固定,比如224x224,那么我们就能计算出它的池化窗口(bin)的大小.比如经过第五个卷积层conv5之后得到的feature map是a x a(13x13),如果金字塔大小n x n,那么窗口大小就是ceil(a / n), 步长是floor(a / n).我们可以用ll个不同大小的窗口,比如3x3, 2x2, 1x1.然后把这ll个输出连接起来,送入之后的全连层.下图是这样3个窗口和最后的全连层的的配置文件. 多个大小训练我们再考虑一种输入大小(180x180),这个180x180的直接取224x224图片的按尺度缩放图片,这两张图除了解析度不同别的都相同.180x180的图片经过第五层卷积后的feature map是10x10,这时我们依然用刚才的公式,窗口大小就是ceil(a / n), 步长是floor(a / n),这样的话后得到的特征长度与之前的224x224的特征长度相同.举个例子,如果金字塔是3*3,即n=3,那么对于第一种大小,窗口长为5,步长4,第二中大小,窗口4,步长3,如下图. 红色区域代表窗口,经过最大池化后,两张图得到的特征向量长度均为3x3=9.所以180的网络和224的网络参数完全一样,于是SPP训练阶段,对于这两种网络只要共享参数即可. 但是在实际训练时,为了减少不停转换网络带来的开销,需要使用全部数据一次训练一个网络,然后再换成第二个,作为一次迭代.所以作者根本没有实现训练不同大小输入的CNN的BP算法,只是针对各种各样大小不同的输入,定义出不同的网络,但这些网络实际上参数都相同,于是就可以用现有工具来训练. SPP-NET物体检测实验R-CNN进行物体检测的方法是,首先从每张图片选出2000个候选窗口,然后把窗口变形到227x227,把每个窗口送入网络计算特征,然后训练SVM进行二分类.R-CNN效果很好,但是对每一张图片的2000个窗口都要送进卷积网络计算,很费时间. SPP-NET可以直接对一张整图计算feature map(以及不同尺度的这张图片),然后只需要在feature map的不同区域进行SPPooling即可,没有了像R-CNN的从头卷积那一步,如下图. 具体的源码可以在 https://github.com/unsky/SPP_net 中找到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[R-CNN-物体检测]]></title>
      <url>%2F2016%2F11%2F22%2FR-CNN%2F</url>
      <content type="text"><![CDATA[Rich feature hierarchies for accurate object detection and semantic segmentation是RBG大神的作品，提出了深度学习用于物体检测的开山之作r-cnn (Regions with Convolutional Neural Network Features) IOU的定义 物体检测需要定位出物体的bounding box，就像下面的图片一样，我们不仅要定位出车辆的bounding box 我们还要识别出bounding box 里面的物体就是车辆。对于bounding box的定位精度，有一个很重要的概念，因为我们算法不可能百分百跟人工标注的数据完全匹配，因此就存在一个定位精度评价公式：IOU。 矩形框A、B的一个重合度IOU计算公式为： $$IOU=\left( A\cap B \right) /\left( A\cup B \right) $$ 就是矩形框A、B的重叠面积占A、B并集的面积比例: 非极大值抑制 就像上面的图片一样，定位一个车辆，最后算法就找出了一堆的方框，我们需要判别哪些矩形框是没用的。非极大值抑制：先假设有6个矩形框，根据分类器类别分类概率做排序，从小到大分别属于车辆的概率分别为A、B、C、D、E、F。 从最大概率矩形框F开始，分别判断A~E与F的重叠度IOU是否大于某个设定的阈值; 假设B、D与F的重叠度超过阈值，那么就扔掉B、D；并标记第一个矩形框F，是我们保留下来的。 从剩下的矩形框A、C、E中，选择概率最大的E，然后判断E与A、C的重叠度，重叠度大于一定的阈值，那么就扔掉；并标记E是我们保留下来的第二个矩形框。 就这样一直重复，找到所有被保留下来的矩形框。 r-cnn的论文思想 在如今看来是非常简单的， 首先在原图中使用selective_search进行窗口的推荐推荐出2000个候选窗口。 然后采用CNN提取每个候选框中图片的特征向量，特征向量的维度为4096维。 接着采用svm算法对各个候选框中的物体进行分类识别 部分实现细节selective_search当我们输入一张图片时，我们要搜索出所有可能是物体的区域，这个采用的方法是传统文献的算法：《search for object recognition》，通过这个算法我们搜索出2000个候选框。然后从上面的总流程图中可以看到，搜出的候选框是矩形的，而且是大小各不相同。然而CNN对输入图片的大小是有固定的，如果把搜索到的矩形选框不做处理，就扔进CNN中，肯定不行。因此对于每个输入的候选框都需要缩放到固定的大小。下面我们讲解要怎么进行缩放处理，为了简单起见我们假设下一阶段CNN所需要的输入图片大小是个正方形图片227*227。因为我们经过selective search 得到的是矩形框，paper试验了两种不同的处理方法： 各向异性缩放,这种方法很简单，就是不管图片的长宽比例，管它是否扭曲，进行缩放就是了，全部缩放到CNN输入的大小227*227，如下图(D)所示； 先把bounding box图片裁剪出来，然后用固定的背景颜色填充成正方形图片(背景颜色也是采用bounding box的像素颜色均值),如下图(C)所示; 对于上面的异性、同性缩放，文献还有个padding处理，上面的示意图中第1、3行就是结合了padding=0,第2、4行结果图采用padding=16的结果。经过最后的试验，作者发现采用各向异性缩放、padding=16的精度最高. fine-tuning阶段我们接着采用selective search 搜索出来的候选框，然后处理到指定大小图片，继续对上面预训练的cnn模型进行fine-tuning训练。假设要检测的物体类别有N类，那么我们就需要把上面预训练阶段的CNN模型的最后一层给替换掉，替换成N+1个输出的神经元(加1，表示还有一个背景)，然后这一层直接采用参数随机初始化的方法，其它网络层的参数不变；接着就可以开始继续SGD训练了。开始的时候，SGD学习率选择0.001，在每次训练的时候，我们batch size大小选择128，其中32个正样本、96个负样本(1:3)note：作者在此论文中给出了卷积层和全连接层的一些特征，拿vgg16而言，网络的卷积层部分可以看作是sift等一样的特征提取器，但是对于全连接层是根据特定任务而言的，比如vgg16是用于图片分类，我们可以直接用其卷积层进行特征提取，而对于全连接，一般需要针对人脸任务进行一部分的微调。 一些附加的调参技巧：在cat vs dog 的二分类竞赛中，发现对于vgg16网络，如果仅仅改变全连接层，那么效果可以达到正确率95%,但是如果微调vgg16的conv5+全连接层可以达到正确率98% 实验效果 具体的实验代码可以在https://github.com/unsky/rcnn中找到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[String to Integer (atoi) 字符转int类型]]></title>
      <url>%2F2016%2F11%2F21%2FString-to-Integer-atoi-%E5%AD%97%E7%AC%A6%E8%BD%ACint%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[id8:String to Integer (atoi) QuestionEditorial Solution My SubmissionsTotal Accepted: 136242Total Submissions: 989232Difficulty: EasyContributors: AdminImplement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. 这道题目正常的转换非常简单，比较麻烦的就是处理边界问题，在测试集里面需要考虑如下集中边界问题： 起始和结束空格问题如 &quot;.&quot; return 0;和 &quot;....-48755....&quot; return -48755, 其中 &quot;.&quot; 表示空格， 去掉问题1后的符号字符问题，比如 +8975 return 8975, 89454 return 89484,-8975 return -8975, 即必须提取出合适的正负号.其中正号可以省略。 去掉1和2问题后的结束字符问题，如，8986jhuuh return 8986. 溢出问题，写此文章时2016/11/21，leetcode已经在此测试集中加入了对long long的溢出判断。所以不能使用long long 类型进行溢出判断。可以使用http://deepdim.com/2016/11/21/Reverse-Integer-%E9%80%86%E7%BD%AEint%E6%95%B0/#more中的溢出方法，即：使用前一个结果得标志 在溢出得时候只有每次乘以10的时候会产生溢出，假设没乘以10之前的结果保存在pre_result,在乘以10之后的结果为 result,可以使用result/10!=pre_result来进行溢出判断，因为如果溢出结果就是一个溢出的数字不满足乘以10的结果 note: 测试集中存在测试字符串 +-8968,在去掉1和2问题之后变为’-8968’等同于&quot;.&quot;,所以return 0,如果不好理解，可以将问题放大：如-895-775在去掉问题1和2的影响后，等同于895所以return 895. 程序代码如下：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int myAtoi(string str) &#123; str.erase(0,str.find_first_not_of(' ')); str.erase(str.find_last_not_of(' ')+1); int result=0; int pre_result; int sigm=1; if(str[0]=='-') &#123;sigm=-1; str=str.substr(1); &#125; else if(str[0]=='+') str=str.substr(1); if (str.length()==0)return 0; for(int i=0;i&lt;str.length();i++) &#123;if(str[i]&lt;'0'||str[i]&gt;'9') break; pre_result=result; result=result*10+str[i]-48; if(result/10!=pre_result)//溢出操作，注意在测试数据集里 Long long 类型也溢出 &#123; if(sigm&lt;0)return INT_MIN; else return INT_MAX; &#125; &#125; return (sigm*result); &#125;&#125;; 本地测试用例：12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int INT_MIN=-2147483648;int INT_MAX=2147483647;class Solution &#123;public: int myAtoi(string str) &#123; str.erase(0,str.find_first_not_of(' ')); str.erase(str.find_last_not_of(' ')+1); int result=0; int pre_result; int sigm=1; if(str[0]=='-') &#123;sigm=-1; str=str.substr(1); &#125; else if(str[0]=='+') str=str.substr(1); if (str.length()==0)return 0; for(int i=0;i&lt;str.length();i++) &#123;if(str[i]&lt;'0'||str[i]&gt;'9') break; pre_result=result; result=result*10+str[i]-48; if(result/10!=pre_result)//溢出操作，注意在测试数据集里 Long long 类型也溢出 &#123; if(sigm&lt;0)return INT_MIN; else return INT_MAX; &#125; &#125; return (sigm*result); &#125;&#125;;int main()&#123; string str; cin&gt;&gt;str; Solution so; cout&lt;&lt;so.myAtoi(str); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Reverse Integer 逆置int数]]></title>
      <url>%2F2016%2F11%2F21%2FReverse-Integer-%E9%80%86%E7%BD%AEint%E6%95%B0%2F</url>
      <content type="text"><![CDATA[id7. Reverse Integer QuestionEditorial Solution My SubmissionsTotal Accepted: 185981Total Submissions: 785209Difficulty: EasyContributors: AdminReverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.Update (2014-11-10):Test cases had been added to test the overflow behavior. 这个题目非常简单，唯一比较麻烦得是判断溢出。 “leetcode判断溢出得方法” 设置最大最小2147483647 ~ -2147483648 在本地环境下没有问题，但是leetcode就不行了，编译环境得问题。 使用前一个结果得标志 在溢出得时候只有每次乘以10的时候会产生溢出，假设没乘以10之前的结果保存在pre_result,在乘以10之后的结果为 result,可以使用result/10!=pre_result来进行溢出判断，因为如果溢出结果就是一个溢出的数字不满足乘以10的结果。 比较啰嗦的借助了一个vector实现： 123456789101112131415161718192021222324252627282930class Solution &#123;public: int reverse(int x) &#123; vector&lt;int&gt; vec; int num; int pre_result=0; int result=0; int flag=1; if (x&lt;=0)&#123; num=-1*x; flag=-1; &#125; if(x&gt;0) num=x; cout&lt;&lt;num; while(num) &#123;vec.push_back(num%10); num=num/10; &#125; vector&lt;int&gt;::iterator it=vec.begin(); for(;it!=vec.end();it++) &#123; pre_result=result; result=result*10+(*it); if (result/10!=pre_result) return 0; &#125; return flag*result; &#125;&#125;; 精简版，不借助容器实现：123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int pre_result=0; int result=0; while(x) &#123;pre_result=result; result=result*10+x%10; x=x/10; if(result/10!=pre_result) return 0; &#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[回声状态网络ESN]]></title>
      <url>%2F2016%2F11%2F18%2F%E5%9B%9E%E5%A3%B0%E7%8A%B6%E6%80%81%E7%BD%91%E7%BB%9CESN%2F</url>
      <content type="text"><![CDATA[ESN( echo state networks):针对递归神经网络训练困难以及记忆渐消问题,jaeger 于2001年提出一种新型递归神经网络— — —回声状态网络. ESN网络一经提出便成为学术界的研究热点，并应用到各种不同领域，包括动态模式分类、机器人控制、对象跟踪核运动目标 检 测、 事 件 监 测 等， 尤其是时间序列预测问题. ESNESN 属于RNN的范畴，具有短期记忆的能力。今天将探讨和实验ESN在时间序列问题上的原理。 时间序列数据往往具有高噪声、随机性以及非线性等特点，其建模、分析以及预测问题一直是学术界研究的热点 ．一般地讲，为了更加准确地预测时间序列，需要时间序列模型既具有良好的非线性逼近能力，又具有良好的记忆能力 ．这对于经典的时间序列建模和分析方法提出极大的挑战 ．为了解决非线性时间序列预测问题，支持向量机、神经网络等人工智能方法被引入到时间序列分析领域. ESN结构 相对于传统神经网络结构ESN所学习的并不是神经元的权重，二是神经元之间的链接。 回声状态状态网络作为一种新型的递归神经网络，无论是建模还是学习算法，都已经与传统的递归神经网络差别很大。 比较直观的结构如下： ESN网络特点： 它的核心结构是一个随机生成、且保持不 变的储备池（Reservoir） 其输出权值是唯一需要调整的部分 简单的线性回归就可完成网络的训练ESN的数学模型 假设系统具有M个输入单元,N个内部处理单元（Processing elements PEs），即N个内部神经元,同时具有L个输出单元,输入单元、内部状态、以及输出单元n时刻的值分别为 $$u\left( n \right) =\left[ u_1\left( n \right) ,…,u_M\left( n \right) \right] ^T$$$$x\left( n \right) =\left[ x_1\left( n \right) ,…,x_N\left( n \right) \right] ^T$$$$y\left( n \right) =\left[ y_1\left( n \right) ,…,y_L\left( n \right) \right] ^T$$其中，$u\left( n \right) \in R^{K\times 1}$ , $x\left( n \right) \in R^{N\times 1}$ , $y\left( n \right) \in R^{L\times 1}$ 从结构上讲，ESNs是一种特殊类型的神经网络，其基本思想是使用大规模随机连接的递归网络，取代经典神经网络中的中间层，从而简化网络的训练过程,回声状态网络的状态方程为：$$x\left( n+1 \right) =f\left( Wx\left( n \right) +W^{in}u\left( n \right) +W^{back}y\left( n \right) \right) $$$$y\left( n+1 \right) =f_{out}\left( W^{out}\left[ x\left( n+1 \right) ,u\left( n+1 \right) ,y\left( n \right) \right] +b^{out} \right)$$ 其中，$W\in R^{N\times N}$ , $W^{in}\in R^{N\times K}$ , $W^{back}\in R^{N\times L}$ , $W^{out}\in R^{\left( L+K+N \right) \times L}$ f为激活函数，一般为双曲正切函数。其中W, $W^{in}$ , $W^{back}$ 分别表示状态变量、输入和输出对状态变量的连接权矩阵；$W^{out}$ 表示储备池、输入和输出对于输出的连接权矩阵，$b^{out}$ 表示输出的偏置项或者可以代表噪声,表示内部神经元激活函数,在网络训练过程中，连接到储备池的连接权矩阵 W, $W^{in}$ , $W^{back}$ 随机产生,一经产生就固定不变.而连接到输出的连接权矩阵 $W^{out}$ 需要通过训练得到，因为状态变量、输入和输出与输出之间是线性关系，所以通常这些连接权只需通过求解线性回归问题得到。 ESN的训练ESNs的训练过程就是根据给定的训练样本 $u\left( n \right) =\left[ u_1\left( n \right) ,…,u_M\left( n \right) \right] ^T$ ，确定系统输出连接权矩阵 $W^{out}$的过程 ．ESNs的训练分为两个过程： 采样过程和权值计算过程 采样过程采样阶段首先任意选定网络的初始状态，但是通常情况下选取网络的初始状态为0，即 $x(0)=0$ ,训练样本$u\left( n \right) =\left[ u_1\left( n \right) ,…,u_M\left( n \right) \right] ^T$ 经过输入连接权矩阵 $W^{in}$ 被加入到储备池中， 按照方程，依次完成系统状态和输出珋 $y(n)$ 的计算与收集 ． 为了计算输出连接权矩阵，需要从某一时刻 m 开始收集（采样）内部状态变量，并以向量 $x\left( n \right) =\left[ x_1\left( n \right) ,…,x_N\left( n \right) \right] ^T$ 为行构成矩阵，同时相应的样本数据 y(n)也被收集，并构成一个列向量 $B\in R^{\left( p-m+1 \right) \times N}$ ,同时相应的样本数据y(n)也被收集，并构成 $T\in R^{\left( p-m+1 \right) \times L}$ 权值计算权值计算就是根据在采样阶段收集到系统状态矩阵和样本数据，计算输出连接权 $W^{out}$ ． 因为状态变量 $x(n)$ 和系统输出 $y(n)$ 之间是线性关系，而需要实现的目标是利用网络实际输出逼近期望输出 :$$y\left( n \right) \approx \hat{y}\left( n \right) =\sum_{i=1}^L{w_{i}^{out}x_i\left( n \right)}$$ 所以损失函数为：$$\underset{w_{i}^{out}}{\min}\frac{1}{p-m+1}\sum_{n=m}^P{\left( y\left( n \right) -\sum_{i=1}^L{w_{i}^{out}x_i\left( n \right)} \right) ^2}$$ 所以其训练过程可以用于计算：$$W^{out}=B^{-1}T $$ 实验实验代码：https://github.com/unsky/esn-rmlp 主程序esn_main.m1234567891011clear;clc;% Generate ESN for trainingnet = esn_net(25, 600, 1);% Generate training data[I_data, T_data] = seq_gen_esn(26);% Train ESNnet_trained = esn_train(net,I_data,T_data);% Test ESN[original_out,net_out,error] = esn_test(net_trained); 训练数据准备 seq_gen_esn 用于产生3000个训练数据123456789101112t = 0 : 3000; % training sequence time intervaly = signal(t); % generate training sequencelen = length(y);incom_data = (rand(1,len)&gt;0.00); % incomplete data ratioy = y.*incom_data;num_subset = len - len_subset + 1; % number of subsetfprintf(&apos;Training sequence generation is in process, please wait...\n&apos;)%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Main Loop &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;for i = (1:num_subset), I_data(i,:) = y(i:len_subset-2+i); T_data(i,:) = y(len_subset-1+i);end; 网络训练esn_train用于网络训练求得 $W^{out}$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556AUC = net.numAllUnits; % number of all unitsIUC = net.numInputUnits; % number of input unitsOUC = net.numOutputUnits; % number of output unitsHUC = net.numHiddenLayer; % number of hidden unitsdrWeights = net.reservoirWeights; % dynamic reservoir weights matrixinWeights = net.inputWeights; % input matrixbkWeights = net.backWeights; % backward weights from output layerouWeights = net.outputWeights; % output weights matrixbl_out = net.bl_out; % type of output neuronint_bk = net.int_bk; % intensity of feedbackattenu = net.attenu; % attenuation ratio for the signal%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Parameter Check &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[inpSize, inpNum] = size(I_data&apos;);[tarSize, tarNum] = size(T_data&apos;);if inpSize ~= IUC, error (&apos;Number of input units and input pattern size do not match.&apos;);end;if tarSize ~= OUC, error (&apos;Number of output units and target pattern size do not match.&apos;);end;if inpNum ~= tarNum, error (&apos;Number of input and output patterns are different.&apos;);end;%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Initialization of Training &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;I_data = attenu*I_data;T_data = attenu*T_data;X(1,:) = zeros(1,HUC); % initial reservoir stateI1_data = [zeros(1,inpSize); I_data]; % add zero to initial inputT1_data = [zeros(1,tarSize); T_data]; % add zero to initial outputtimeflag= cputime; % a timer to save the training timewb = waitbar(0, &apos;Echo State Network Training in Progress...&apos;);T0 = 1000; % washout timefprintf(&apos;\nThe echo state network training is in process...\n&apos;);%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Main Loop of ESN Training &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;for i = (1:inpNum), waitbar(i/inpNum,wb) set(wb,&apos;name&apos;,[&apos;Progress = &apos; sprintf(&apos;%2.1f&apos;,i/inpNum*100) &apos;%&apos;]); X(i+1,:) = hyperb((inWeights*I1_data(i+1,:)&apos; + drWeights*X(i,:)&apos; + ... int_bk*bkWeights*T1_data(i,:)&apos; + 0.001*(rand(1,HUC)-0.5)&apos;)&apos;);end;close(wb);fprintf(&apos;Please wait for another while...\n&apos;);%&gt;&gt;&gt;&gt;&gt;&gt; Calculate output weights and update ESN &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;if (bl_out == 1), ouWeights = (pinv(X(T0+2:end,:))*(T_data(T0+1:end,:)))&apos;; % linear outputelse ouWeights = (pinv(X(T0+2:end,:))*(inv_hyperb(T_data(T0+1:end,:))))&apos;;end;net.outputWeights = ouWeights;net_trained = net;timeflag = cputime - timeflag;fprintf(&apos;Training accomplished! Total time is %2.2f hours.\n&apos;,timeflag/3600); 测试结果esn_test123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Obtain parameters from RMLP net &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;AUC = net.numAllUnits; % number of all unitsIUC = net.numInputUnits; % number of input unitsOUC = net.numOutputUnits; % number of output unitsHUC = net.numHiddenLayer; % number of hidden unitsdrWeights = net.reservoirWeights; % dynamic reservoir weights matrixinWeights = net.inputWeights; % input matrixbkWeights = net.backWeights; % backward weights from output layerouWeights = net.outputWeights; % output weights matrixlen_subset= IUC + OUC; % subset lengthbl_out = net.bl_out; % type of output neuronint_bk = net.int_bk; % intensity of feedbackattenu = net.attenu; % attenuation ratio for the signal%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Testing Parameters Setting &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;S_point = 4000; % starting point of testing datatestNum = 3000; % number of testing dataX(1,:) = zeros(1,HUC); % initial reservoir statet = [S_point : S_point+len_subset-1];y0 = rand(1,OUC)-0.5; % initial output%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Check parameter &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;if length(t) ~= len_subset, error(&apos;Length of testing data subset and the network structure do not match&apos;);end;%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Testing Main Routine &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;wb = waitbar(0, &apos;Echo State Network Testing in Progress...&apos;);for i = (1:testNum), waitbar(i/testNum,wb) set(wb,&apos;name&apos;,[&apos;Progress = &apos; sprintf(&apos;%2.1f&apos;,i/testNum*100) &apos;%&apos;]); y = attenu*signal(t); % generate testing data X(i+1,:) = hyperb((inWeights*y(1:end-OUC)&apos; + ... drWeights*X(i,:)&apos; + int_bk*bkWeights*y0&apos;)&apos;); % update reservoir state if (bl_out == 1), Y(i+1,:) = ouWeights*X(i+1,:)&apos;; % update output state - Linear output else Y(i+1,:) = hyperb(ouWeights*X(i+1,:)&apos;); % update output state - nonlinear output end; % update state for next iteration and output original_out(i) = (1/attenu)*y(end-OUC+1:end); % original output net_out(i) = (1/attenu)*Y(i+1,:); % network output error(i) = net_out(i) - original_out(i); % errors y0 = Y(i+1,:); % store the output for next calculation t = t + 1; % Move one-step forwardend;close(wb);%&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Plotting &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;subplot(211);plot([S_point+1:S_point+testNum],original_out,&apos;b&apos;,[S_point+1:S_point+testNum],net_out,&apos;r&apos;);hold on; grid on;legend(&apos;Original sequence&apos;,&apos;Network output&apos;);xlabel(&apos;time&apos;); ylabel(&apos;Amplitude&apos;);subplot(212);plot([S_point+1:S_point+testNum],error,&apos;b&apos;);hold on; grid on;xlabel(&apos;Time&apos;); ylabel(&apos;Output error&apos;);RMSE = sqrt(mean((net_out(1:end) - original_out(1:end)).^2)) 实验结果从错误率可以看出，ESNs的误差率可以接受。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fast-r-cnn-物体检测]]></title>
      <url>%2F2016%2F11%2F14%2Ffast-r-cnn-%E7%89%A9%E4%BD%93%E6%A3%80%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[这是RBG大神对于R-CNN的改进，从上一篇RCNN http://deepdim.com/2016/11/22/R-CNN/中我们知道R-CNN，同时知道SPP-NET可以惊醒任意尺寸的输入同时不需要对没个候选窗口进行输入，而是输入整张图片，在卷积层之后进行窗口推荐。结合两者的优点，所以RBG大神就此提出了fast-r-cnn. 网络结构具体的结构不同在于卷积层之后： 具体步骤 经过多层的卷积和pooling得到一组feature map 通过SPP net中的ROI projection在这层feature map上找到原图的proposal对应的区域（ROI） 利用spatial pooling的思路，对每个ROI做pooling。具体来说就是把h×w的ROI划分为H×W个grid/sub-window，每个grid大小是h/H × w/W，在每个grid内取max。 把ROI pooling layer对每个ROI（对应回原图就是每个proposal）输出的H×W长的max pooling feature vector接全连接层 全连接层之后有两个输出层，一个softmax分类器，输出该ROI对应的proposal的object类别，一个是bounding box回归层，输出category specific bounding box训练可以看出该网络最大的创新是在]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZigZag Conversion 回旋字符串]]></title>
      <url>%2F2016%2F11%2F14%2FZigZag-Conversion-%E5%9B%9E%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
      <content type="text"><![CDATA[id：6. ZigZag Conversion QuestionEditorial Solution My SubmissionsTotal Accepted: 120341Total Submissions: 469716Difficulty: EasyContributors: AdminThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) And then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.Subscribe to see which companies asked this question 这道题是一个变换，只要找到其中的规律就很好做题。 假设结果存在一个string result中 原字符串存于s 经过观察我们可以发现红色部分的变换为： result.append(1,s[j*(numRows+numRows-2)+i]) 绿色部分的变换为 result.append(1,s[(j+1)*(numRows+numRows-2)-i]) 其中i是第i行，j是（红色或者绿）的第j个数 所以我们可以这么写代码：1234567891011121314151617181920212223242526class Solution &#123;public: string convert(string s, int numRows) &#123; string result; if (numRows==1) return s; if(s.size()==0)return result; for(int i=0;i&lt;numRows;i++) &#123; for(int j=0;(j*(numRows+numRows-2)+i)&lt;s.size();j++) &#123;result.append(1,s[j*(numRows+numRows-2)+i]); if(i==0||i==numRows-1) continue; if(((j+1)*(numRows+numRows-2)-i)&lt;s.size()) &#123; result.append(1,s[(j+1)*(numRows+numRows-2)-i]); &#125; &#125; &#125; return result; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PCA主成分分析]]></title>
      <url>%2F2016%2F11%2F12%2FPCA%E9%99%8D%E7%BB%B4%2F</url>
      <content type="text"><![CDATA[pca降维 pca降维]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最大回文串 Longest Palindromic Substring]]></title>
      <url>%2F2016%2F11%2F11%2F%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E4%B8%B2-Longest-Palindromic-Substring%2F</url>
      <content type="text"><![CDATA[id5. Longest Palindromic Substring QuestionEditorial Solution My SubmissionsTotal Accepted: 147621Total Submissions: 614546Difficulty: MediumContributors: AdminGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad” Output: “bab” Note: “aba” is also a valid answer.Example: Input: “cbbd” Output: “bb”最长回文串,首先最容易想到的是穷举所有的字串，然后判断是不是回文。最开始的方法使用递归判断是不是回文：12345678910111213141516171819202122232425262728293031323334//这是一种超时但是正确的做法。但是超时了。。#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;bool isPalindromic(string s,int i,int j)&#123; if (i==j) return 1; if(s[i]!=s[j]) return 0; if (i+1==j) return 1; return isPalindromic(s,i+1,j-1);&#125; string longestPalindrome(string s) &#123; string longestPalindromeString =s.substr(0,1); string str; for(int i=0;i!=s.size();i++) &#123; for(int j=i;j!=s.size();j++) &#123; str=s.substr(i,j-i+1); if(isPalindromic(str,0,str.size()-1)&amp;&amp;(str.size()&gt;longestPalindromeString.size())) longestPalindromeString=str; &#125; &#125; return longestPalindromeString; &#125;int main()&#123; string s="sdgdfhfgjhgghkjhljkldyhrtiiiiytrewqtyitutyiyopuip";cout&lt;&lt;longestPalindrome(s); return 0;&#125; 总结上面的做法，时间复杂度为 $o\left( n^2\log ^n \right) $会发现做了很多重复的事情所以时间复杂度非常高，所以将思路变成穷举中心点，从中心按照奇数和偶数进行扩散，进而在扩散的过程就完成了回文的判断。节省了判断回文的时间。1234567891011121314151617181920212223class Solution &#123;public: string longestPalindrome(string s) &#123; string longestPalindromeString =s.substr(0,1); for(int i=0;i!=s.size();i++) &#123; //奇数 for(int j=0;((i-j)&gt;=0)&amp;&amp;((i+j)&lt;=s.size()-1);j++) &#123;if(s[i-j]!=s[i+j]) break; if ((2*j+1)&gt;longestPalindromeString.size()) longestPalindromeString=s.substr(i-j,2*j+1); &#125; //偶数 for(int j=0;((i-j)&gt;=0)&amp;&amp;((i+j+1)&lt;=s.size()-1);j++) &#123; if(s[i-j]!=s[i+j+1]) break; if ((2*j+2)&gt;longestPalindromeString.size()) longestPalindromeString=s.substr(i-j,2*j+2); &#125; &#125; return longestPalindromeString; &#125;&#125;; 这样的时间复杂度就为 $o\left( n^2 \right) $顺别说一点，在写类的时候不要忘了在类后面加 ;号，不然会提示 error: expected unqualified-id before string constant]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[激活函数]]></title>
      <url>%2F2016%2F11%2F10%2F%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[在神经元的数学模型中，轴突所携带的信号(例如: $x_0$ )通过突触进行传递，由于突触的强弱不一，假设我们以 $w_0$ 表示，那么我们传到下一个神经元的树突处的信号就变成了 $w_0x_0$ 。其中突触强弱(参数w)是可学的，它控制了一个神经元对另一个神经元影响的大小和方向（正负）。然后树突接收到信号后传递到神经元内部cell body，与其他树突传递过来的信号一起进行加和，如果这个和的值大于某一个固定的阈值的话，神经元就会被激活，然后传递冲激信号给树突。在数学模型中我们假设传递冲激信号的时间长短并不重要，只有神经元被激活的频率用于传递信息. 我们将是否激活神经元的函数称为激活函数(activation function $f$ ), 它代表了轴突接收到冲激信号的频率。以前我们比较常用的一个激活信号是sigmoid function $σ$ ，因为它接收一个实值的信号（即上面所说的加和的值）然后将它压缩到 0-1 的范围内。我们在后面会介绍更多的激活函数。 传统Sigmoid系激活函数传统神经网络中最常用的两个激活函数，Sigmoid系（Logistic-Sigmoid、Tanh-Sigmoid）被视为神经网络的核心所在。从数学上来看，非线性的Sigmoid函数对中央区的信号增益较大，对两侧区的信号增益小，在信号的特征空间映射上，有很好的效果。从神经科学上来看，中央区酷似神经元的兴奋态，两侧区酷似神经元的抑制态，因而在神经网络学习方面，可以将重点特征推向中央区，将非重点特征推向两侧区。 sigmoid激活函数sigmoid将一个实数输入映射到[0,1]范围内，如下图（左）所示。使用sigmoid作为激活函数存在以下几个问题： 梯度饱和。当函数激活值接近于0或者1时，函数的梯度接近于0。在反向传播计算梯度过程中:$$\delta^{\left(l\right)}=\left( W^{\left(l\right)} \right) ^T\delta ^{\left(l+1\right)}\cdot f’\left( z^{\left(L\right)}\right) $$，每层残差接近于0，计算出的梯度也不可避免地接近于0。这样在参数微调过程中，会引起参数弥散问题，传到前几层的梯度已经非常靠近0了，参数几乎不会再更新。 函数输出不是以0为中心的。我们更偏向于当激活函数的输入是0时，输出也是0的函数. tanh激活函数tanh函数将一个实数输入映射到[-1,1]范围内，如上图（右）所示。当输入为0时，tanh函数输出为0，符合我们对激活函数的要求。然而，tanh函数也存在梯度饱和问题，导致训练效率低下。 Softplus&amp;ReLu 2001年，神经科学家Dayan、Abott从生物学角度，模拟出了脑神经元接受信号更精确的激活模型，该模型如左图所示：这个模型对比Sigmoid系主要变化有三点：单侧抑制 相对宽阔的兴奋边界 稀疏激活性（重点，可以看到红框里前端状态完全没有激活）同年，Charles Dugas等人在做正数回归预测论文中偶然使用了Softplus函数，Softplus函数是Logistic-Sigmoid函数原函数。 Softplus激活函数公式：$$softplus\left( x \right) =\log \left( 1+e^x \right)$$ 按照论文的说法，一开始想要使用一个指数函数（天然正数）作为激活函数来回归，但是到后期梯度实在太大，难以训练，于是加了一个log来减缓上升趋势。加了1是为了保证非负性。同年，Charles Dugas等人在NIPS会议论文中又调侃了一句，Softplus可以看作是强制非负校正函数 $max(0,x)$ 平滑版本。偶然的是，同是2001年，ML领域的Softplus/Rectifier激活函数与神经科学领域的提出脑神经元激活频率函数有神似的地方，这促成了新的激活函数的研究。 ReLURelu激活函数（The Rectified Linear Unit）表达式为：$$f(x)=max(0,x)$$ 相比sigmoid和tanh函数，Relu激活函数的优点在于： 梯度不饱和。梯度计算公式为：1{x&gt;0}。因此在反向传播过程中，减轻了梯度弥散的问题，神经网络前几层的参数也可以很快的更新。 计算速度快。正向传播过程中，sigmoid和tanh函数计算激活值时需要计算指数，而Relu函数仅需要设置阈值。如果x0,f(x)=x。加快了正向传播的计算速度。 因此，Relu激活函数可以极大地加快收敛速度，相比tanh函数，收敛速度可以加快6倍（如上图（右）所示）。 激活函数的发展PReLUdsdPReLU 是ReLU 和 LReLU的改进版本，具有非饱和性： 与LReLU相比，PReLU中的负半轴斜率a可学习而非固定。原文献建议初始化a为0.25，不采用正则。个人认为，是否采用正则应当视具体的数据库和网络，通常情况下使用正则能够带来性能提升。 虽然PReLU 引入了额外的参数，但基本不需要担心过拟合。例如，在上述cifar10+NIN实验中， PReLU比ReLU和ELU多引入了参数，但也展现了更优秀的性能。所以实验中若发现网络性能不好，建议从其他角度寻找原因。 与ReLU相比，PReLU收敛速度更快。因为PReLU的输出更接近0均值，使得SGD更接近natural gradient。证明过程参见原文[10]。 此外，作者在ResNet 中采用ReLU，而没有采用新的PReLU。这里给出个人浅见，不一定正确，仅供参考。首先，在上述LReLU实验中，负半轴斜率对性能的影响表现出一致性。对PReLU采用正则将激活值推向0也能够带来性能提升。这或许表明，小尺度或稀疏激活值对深度网络的影响更大。其次，ResNet中包含单位变换和残差两个分支。残差分支用于学习对单位变换的扰动。如果单位变换是最优解，那么残差分支的扰动应该越小越好。这种假设下，小尺度或稀疏激活值对深度网络的影响更大。此时，ReLU或许是比PReLU更好的选择. RReLU数学形式与PReLU类似，但RReLU[9]是一种非确定性激活函数，其参数是随机的。这种随机性类似于一种噪声，能够在一定程度上起到正则效果。作者在cifar10/100上观察到了性能提升。 MaxoutMaxout[13]是ReLU的推广，其发生饱和是一个零测集事件（measure zero event）。正式定义为：$$\max \left( w_{1}^{T}x+b_1,…,w_{n}^{T}x+b_n \right) $$Maxout网络能够近似任意连续函数，且当w2,b2,…,wn,bn为0时，退化为ReLU。 其实，Maxout的思想在视觉领域存在已久。例如，在HOG特征里有这么一个过程：计算三个通道的梯度强度，然后在每一个像素位置上，仅取三个通道中梯度强度最大的数值，最终形成一个通道。这其实就是Maxout的一种特例。 Maxout能够缓解梯度消失，同时又规避了ReLU神经元死亡的缺点，但增加了参数和计算量。 ELUELU 融合了sigmoid和ReLU，具有左侧软饱性。其正式定义为： 右侧线性部分使得ELU能够缓解梯度消失，而左侧软饱能够让ELU对输入变化或噪声更鲁棒。ELU的输出均值接近于零，所以收敛速度更快。经本文作者实验，ELU的收敛性质的确优于ReLU和PReLU。在cifar10上，ELU 网络的loss 降低速度更快；在 ImageNet上，不加 Batch Normalization 30 层以上的 ReLU 网络会无法收敛，PReLU网络在MSRA的Fan-in （caffe ）初始化下会发散，而 ELU 网络在Fan-in/Fan-out下都能收敛 。 论文的另一个重要贡献是分析了Bias shift 现象与激活值的关系，证明了降低Bias shift 等价于把激活值的均值推向0。 MPELU将分段线性与ELU统一到了一种形式下。在NIN+CIFAR10，本文作者发现ELU与LReLU性能一致，而与PReLU差距较大。经过分析，ELU泰勒展开的一次项就是LReLU。当在ELU前加入BN让输入集中在0均值附近， 则ELU与LReLU之差——泰勒展开高次项会变小，粗略估计，约55.57%的激活值误差小于0.01。因此，受PReLU启发，令α可学习能够提高性能。此外，引入参数β能够进一步控制ELU的函数形状。正式定义为α 和 β可以使用正则。α, β 固定为1时，MPELU 退化为 ELU； β 固定为很小的值时，MPELU 近似为 PReLU；当α=0，MPELU 等价于 ReLU。 MPELU 的优势在于同时具备 ReLU、PReLU和 ELU的优点。首先，MPELU具备ELU的收敛性质，能够在无 Batch Normalization 的情况下让几十层网络收敛。其次，作为一般化形式， MPELU较三者的推广能力更强。简言之，MPELU = max(ReLU, PReLU, ELU)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[损失函数]]></title>
      <url>%2F2016%2F11%2F10%2F%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[损失函数（loss function）是用来估量模型的预测值 $f(x)$ 与真实值Y的不一致程度，它是一个非负实值函数,通常使用 $L(Y, f(x))$ 来表示，损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下式子：$$\theta^{*}=arg\underset{\theta}{\min}\frac{1}{N}\sum_{i=1}^N{L\left( y_i,f\left( x_i;\theta \right) \right) +\lambda \varPhi \left( \theta \right)}$$ 其中，前面的均值函数表示的是经验风险函数，L代表的是损失函数，后面的 $\varPhi$ 是正则化项（regularizer）或者叫惩罚项（penalty term），它可以是L1，也可以是L2，或者其他的正则函数。整个式子表示的意思是找到使目标函数最小时的θ 值。下面主要列出几种常见的损失函数。 log对数损失函数（逻辑回归）有些人可能觉得逻辑回归的损失函数就是平方损失，其实并不是。平方损失函数可以通过线性回归在假设样本是高斯分布的条件下推导得到，而逻辑回归得到的并不是平方损失。在逻辑回归的推导中，它假设样本服从伯努利分布（0-1分布），然后求得满足该分布的似然函数，接着取对数求极值等等。而逻辑回归并没有求似然函数的极值，而是把极大化当做是一种思想，进而推导出它的经验风险函数为：最小化负的似然函数（即max F(y, f(x)) —-&gt; min -F(y, f(x)))。从损失函数的视角来看，它就成了log损失函数了。 log损失函数的标准形式：$$ L\left( Y,P\left( Y|X \right) \right) =-\log P\left( Y|X \right)$$刚刚说到，取对数是为了方便计算极大似然估计，因为在MLE中，直接求导比较困难，所以通常都是先取对数再求导找极值点。损失函数 $L(Y, P(Y|X))$ 表达的是样本X在分类Y的情况下，使概率 $P(Y|X)$ 达到最大值（换言之，就是利用已知的样本分布，找到最有可能（即最大概率）导致这种分布的参数值；或者说什么样的参数才能使我们观测到目前这组数据的概率最大）。因为log函数是单调递增的，所以 $logP(Y|X)$ 也会达到最大值，因此在前面加上负号之后，最大化 $P(Y|X)$ 就等价于最小化 $L$ 了。逻辑回归的 $P(Y=y|x)$ 表达式如下（为了将类别标签y统一为1和0，下面将表达式分开表示)：将它带入到上式，通过推导可以得到logistic的损失函数表达式，如下：逻辑回归最后得到的目标式子如下：$$J\left( \theta \right) =-\frac{1}{m}\sum_{i=1}^m{\left[ y^i\log h_{\theta}\left( x^i \right) +\left( 1-y^i \right) \log \left( 1-h_{\theta}\left( x^i \right) \right) \right]}$$上面是针对二分类而言的。 平方损失函数（最小二乘法, Ordinary Least Squares ）最小二乘法是线性回归的一种，OLS将问题转化成了一个凸优化问题。在线性回归中，它假设样本和噪声都服从高斯分布（为什么假设成高斯分布呢？其实这里隐藏了一个小知识点，就是中心极限定理，可以参考central limit theorem），最后通过极大似然估计（MLE）可以推导出最小二乘式子。最小二乘的基本原则是：最优拟合直线应该是使各点到回归直线的距离和最小的直线，即平方和最小。换言之，OLS是基于距离的，而这个距离就是我们用的最多的欧几里得距离。为什么它会选择使用欧式距离作为误差度量呢（即Mean squared error， MSE），主要有以下几个原因： 简单，计算方便； 欧氏距离是一种很好的相似性度量标准； 在不同的表示域变换后特征性质不变。平方损失（Square loss）的标准形式如下：$$L\left( Y,f\left( X \right) \right) =\left( Y-f\left( X \right) \right) ^2$$当样本个数为n时，此时的损失函数变为：$$L\left( Y,f\left( X \right) \right) =\sum_{i=1}^n{\left( Y-f\left( X \right) \right) ^2}$$$Y-f(X)$ 表示的是残差，整个式子表示的是残差的平方和，而我们的目的就是最小化这个目标函数值（注：该式子未加入正则项），也就是最小化残差的平方和（residual sum of squares，RSS）。而在实际应用中，通常会使用均方差（MSE）作为一项衡量指标，公式如下：$$MSE=\frac{1}{n}\sum_{i=1}^n{\left( \widetilde{Y_i}-Y_i \right) ^2}$$note： 其求解过程转化为LSR(最小二乘回归)在求解时候。 加入L1惩罚项，将变为 lasso问题，具体对lasso的求解将另起一文 加入L2惩罚项，将变为岭回归问题 指数损失函数（Adaboost）学过Adaboost算法的人都知道，它是前向分步加法算法的特例，是一个加和模型，损失函数就是指数函数。在Adaboost中，经过m此迭代之后，可以得到$$f_m\left( x \right) =f_{m-1}\left( x \right) +\alpha _mG_m\left( x \right) $$Adaboost每次迭代时的目的是为了找到最小化下列式子时的参数α 和G：$$arg\underset{\alpha ,G}{\min}=\sum_{i=1}^N{\exp \left[ -y_i\left( f_{m-1}\left( x_i \right) +\alpha G\left( x_i \right) \right) \right]}$$而指数损失函数(exp-loss）的标准形式如下 $$L\left( Y,f\left( X \right) \right) =\exp \left[ -yf\left( x \right) \right] $$ 可以看出，Adaboost的目标式子就是指数损失，在给定n个样本的情况下，Adaboost的损失函数为： $$L\left( Y,f\left( X \right) \right) =\frac{1}{n}\sum_{i=1}^n{\exp \left[ -yf\left( x \right) \right]}$$ Hinge损失函数（SVM）在机器学习算法中，hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于下列式子：$$\underset{w,b}{\min}\sum_i^N{\left[ 1-y_i\left( w\cdot x_i+b \right) \right] _++\lambda ||w||^2}$$下面来对式子做个变形，令：$$\left[ 1-y_i\left( w\cdot x_i+b \right) \right] _+=\xi _i$$于是，原式就变成了：$$\underset{w,b}{\min}\sum_i^N{\xi _i+\lambda ||w||^2}$$另 $\lambda =\frac{1}{2C}$ $$\underset{w,b}{\min}\frac{1}{C}\left( C\sum_i^N{\xi _i+\frac{1}{2}||w||^2} \right)$$可以看出，该式子与下式非常相似： Hinge 损失函数的标准形式:$$L\left( y \right) =\max \left( 0,1-y\tilde{y} \right) ,y=\pm 1$$可以看出，当 $|y|&gt;=1$ 时，$L(y)=0$ 。 其它损失函数0-1损失函数 绝对值损失函数 总结参数越多，模型越复杂，而越复杂的模型越容易过拟合。过拟合就是说模型在训练数据上的效果远远好于在测试集上的性能。此时可以考虑正则化，通过设置正则项前面的hyper parameter，来权衡损失函数和正则项，减小参数规模，达到模型简化的目的，从而使模型具有更好的泛化能力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聚类分析]]></title>
      <url>%2F2016%2F11%2F09%2F%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[聚类分析将数据划分成有意义或有用的组（簇）。聚类分析仅根据在数据中发现的描述对象及其关系的信息，将数据对象分组。其目标是，组内的对象相互之间是相似的，而不同组中的对象是不同的。 聚类一个好的聚类方法要能产生高质量的聚类结果——簇，这些簇要具备以下两个特点： 高的簇内相似性 低的簇间相似性 聚类结果的好坏取决于该聚类方法采用的相似性评估方法以及该方法的具体实现聚类方法的好坏还取决于该方法是否能发现某些还是所有的隐含模式 聚类可以分为： 划分聚类（Partitional Clustering） 层次聚类（Hierarchical Clustering） 互斥（重叠）聚类（exclusive clustering） 非互斥聚类（non-exclusive） 模糊聚类（fuzzy clustering） 完全聚类（complete clustering） 部分聚类（partial clustering） 划分聚类划分聚类简单地将数据对象集划分成不重叠的子集，使得每个数据对象恰在一个子集。 层次聚类层次聚类是嵌套簇的集族，组织成一棵树。 互斥聚类（exclusive）每个对象都指派到单个簇. 重叠聚类（overlapping）或非互斥聚类（non-exclusive）聚类用来反映一个对象.同时属于多个组（类）这一事实。例如：在大学里，一个人可能既是学生，又是雇员 模糊聚类（Fuzzy clustering ）每个对象以一个0（绝对不属于）和1（绝对属于）之间的隶属权值属于每个簇。换言之，簇被视为模糊集。 部分聚类（Partial）部分聚类中数据集某些对象可能不属于明确定义的组。如：一些对象可能是离群点、噪声。 完全聚类（complete）完全聚类将每个对象指派到一个簇。 概念簇的分类簇是同一性状物体的集合按照性状的分类不同可以将簇分为 明显分离的 每个点到同簇中任一点的距离比到不同簇中所有点的距离更近。 基于原型的 每个对象到定义该簇的原型的距离比到其他簇的原型的距离更近。对于具有连续属性的数据，簇的原型通常是质心，即簇中所有点的平均值。当质心没有意义时，原型通常是中心点，即簇中最有代表性的点。 基于中心的（ Center-Based）的簇：每个点到其簇中心的距离比到任何其他簇中心的距离更近。 基于图的 如果数据用图表示，其中节点是对象，而边代表对象之间的联系。 簇可以定义为连通分支（connected component）：互相连通但不与组外对象连通的对象组。 基于近邻的（ Contiguity-Based）：其中两个对象是相连的，仅当它们的距离在指定的范围内。这意味着，每个对象到该簇某个对象的距离比到不同簇中任意点的距离更近。 基于密度的 簇是对象的稠密区域，被低密度的区域环绕。 概念簇可以把簇定义为有某种共同性质的对象的集合。例如：基于中心的聚类。还有一些簇的共同性质需要更复杂的算法才能识别出来。 本系列文章将探究各个聚类方式之间的区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[互斥聚类-k-means聚类]]></title>
      <url>%2F2016%2F11%2F09%2Fk-means%E8%81%9A%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[在数据挖掘中，K-Means算法是一种cluster analysis的算法， 其主要是来计算数据聚集算法，主要通过不断地取离种子点最近均值的算法。 问题K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们用肉眼可以看出来有四个点群，但是我们怎么通过计算机程序找出这几个点群来呢？ 于是就出现了我们的K-Means算法。算法概要如下图所示：从上图中，我们可以看到，A，B，C，D，E是五个在图中点。而灰色的点是我们的种子点，也就是我们用来找点群的点。有两个种子点，所以K=2。 然后，K-Means的算法如下： 12345671. 随机在图中取K（这里K=2）个种子点2. 然后对图中的所有点求到这K个种子点的距离，假如点Pi离种子点Si最近，那么Pi属于Si点群。（上图中，我们可以看到A，B属于上面的种子点，C，D，E属于下面中部的种子点）3. 我们要移动种子点到属于他的“点群”的中心。（见图上的第三步）然后重复第2）和第3）步直到，种子点没有移动（我们可以看到图中的第四步上面的种子点聚合了A，B，C，下面的种子点聚合了D，E）。 使用公式可以表示为：$$\varUpsilon =\sum_{k=1}^K{\sum_{i=1}^L{dist\left( x_i-u_k \right)}}$$而$dist$距离函数可以分为： Minkowski Distance（闵可夫斯基距离）$$d_{i,j}=\sqrt[\lambda]{\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}^{\lambda}}$$$\lambda$ 可以随意取值，可以是负数，也可以是正数，或是无穷大 Euclidean Distance(欧拉距离) $$d_{i,j}=\sqrt[]{\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}^2}$$其形式为 Minkowski Distance 为 $\lambda$=2时候的特殊形式。 CityBlock Distance （CB距离）$$d_{i,j}=\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}$$也就是第一个公式 $\lambda$=1的情况。 实验实验目的在模拟k-means的实验中我们使用深度学习网络vgg16在一个层的feature maps 来进行模拟实验，用来验证聚类效果，输入图片为一个行人。我们使用vgg16 conv1-2产生的feature maps进行实验。假设我们产生的feature maps 为 $\psi \in R^{m\times n\times k}$ ,其中 $m\times n$ 为feature大小, k为map的个数。首先每个feature进行向量化，从而将其转化为 $\psi \in R^{m* n\times k}$ 。使用k-means对一个层的feature maps进行聚类，并可视化效果。本实验中使用欧式距离。 工具 实验使用vlfeat工具包下载地址： https://github.com/unsky/vlfeat 在vlfeat\toolbox中使用vl_setup启动工具包 实验过程假设feature maps已经存在于 res1.mat 中运行代码12345678910111213load(&apos;res1.mat&apos;);a=res(23).x;[w,e,r]=size(a);a=reshape(a,w*e,r); [C, A] = vl_kmeans(a, 10) ; for i=1:10, fea=C(:,i); fea=reshape(fea,w,e); n = mapminmax(fea, 0, 1); subplot(2,5,i); imshow(n); hold on; end 实验结果 原始64个feature的可视化： k-means （k=10） k=5 k=1 k-means 优缺点 优点： 算法简单 适用于球形簇 二分k均值等变种算法运行良好，不受初始化问题的影响。 缺点： 不能处理非球形簇、不同尺寸和不同密度的簇 对离群点、噪声敏感]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手将atom打造成c++/c编程利器]]></title>
      <url>%2F2016%2F11%2F08%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B0%86atom%E6%89%93%E9%80%A0%E6%88%90c-c%E7%BC%96%E7%A8%8B%E5%88%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。多数的延伸包皆为开放源代码授权，并由社区建置与维护。Atm基于Chromium并使用CoffeeScript撰写。Atom也可当作IDE使用。 安装atom 原则自己的平台安装，本文所有操作均在 win10中进行。 官方下载地址：https://atom.io/ 安装之后进入欢迎界面 原始的atom已经安装了一些插件。但是我们需要将其打造成一个c/c++ IDE. 编译和调试插件 gpp-compliler编译和调试是ide的基本功能不可或缺。 gpp-compliler 安装依赖于 MinGW 下载地址：http://www.mingw.org/ MinGW(Minimalist GNU For Windows)是个精简的Windows平台C/C++、ADA及Fortran编译器，相比Cygwin而言，体积要小很多，使用较为方便。 运行刚刚下载的安装程序 安装到D:\MinGW，点”Continue”。之后在桌面会形成一个安装器： 运行 选择安装组件 运行安装程序。 选择需要安装的组件，右键选择Mark for Installation,之后选择Installation -&gt; Apply Changes。 GCC 这里重点要提到的是GCC组件的安装，如图所示 先选择左边的”MinGW Base System”选项，之后再右边找到mingw-gcc。最好选择bin,dev和lic三个组件进行安装。 配置 设置MinGW环境变量鼠标右键“我的电脑”-&gt;“属性”，选择“高级”选项卡下的“环境变量”，在系统变量里点“新建”，之后填写MinGW的安装路径，如下： 之后找到Path，在最前面添加下面这段声明，之后点击确定。安装完成后，在MinGW\bin的目录下，会有一个名为gcc.exe的可执行文件。在 cmd 运行 gcc -v会出现版本信息，如果显示，则安装成功。回到atom,新建一个cpp文件，代码中我们加个错误 123456789101112#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int aaa; cin&gt;&gt;aaa;aa cout&lt;&lt;aaa&lt;&lt;endl; return 0;&#125; 运行 F5 错误提示在右上角。 将代码修改正确 显示控制台结果. 代码错误检测 linter-gcclinter-gcc 安装依赖于linter 首先安装linter包。同时还依赖于 gcc 在上一步我们已经安装了gcc并且已经加入了路径，如果没有请自行安装。 只需在 linter-gcc的设置里面 F5 运行一段代码错误代码，可以显示： 到这里 atom已经可以完成我们编译所需的环境，剩下的可以进一步就行优化推荐一些优秀的插件 高亮选择 highlight-selected可以高亮选择的关键字 自动美化代码 atom-beautifulminimap和submit一种风格的快速浏览窗口。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[卷积神经网络]]></title>
      <url>%2F2016%2F11%2F02%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[神经网络算法领域最初是被对生物神经系统建模这一目标启发，但随后与其分道扬镳，成为一个工程问题，并在机器学习领域取得良好效果。然而，讨论将还是从对生物系统的一个高层次的简略描述开始，因为神经网络毕竟是从这里得到了启发. 神经元建模 大脑的基本计算单位是神经元（neuron）。人类的神经系统中大约有860亿个神经元，它们被大约10^14-10^15个突触（synapses）连接起来。下面图表的左边展示了一个生物学的神经元，右边展示了一个常用的数学模型。每个神经元都从它的树突获得输入信号，然后沿着它唯一的轴突（axon）产生输出信号。轴突在末端会逐渐分枝，通过突触和其他神经元的树突相连。 在神经元的计算模型中，沿着轴突传播的信号（比如 $x_0$ ）将基于突触的突触强（比如 $w_0$ ），与其他神经元的树突进行乘法交互（比如$w_0x_0$）。其观点是，突触的强度（也就是权重），是可学习的且可以控制一个神经元对于另一个神经元的影响强度（还可以控制影响方向：使其兴奋（正权重）或使其抑制（负权重））。在基本模型中，树突将信号传递到细胞体，信号在细胞体中相加。如果最终之和高于某个阈值，那么神经元将会激活，向其轴突输出一个峰值信号。在计算模型中，我们假设峰值信号的准确时间点不重要，是激活信号的频率在交流信息。基于这个速率编码的观点，将神经元的激活率建模为激活函数（activation function）f，它表达了轴突上激活信号的频率。由于历史原因，激活函数常常选择使用sigmoid函数 $\sigma$，该函数输入实数值（求和后的信号强度），然后将输入值压缩到0-1之间。在本节后面部分会看到这些激活函数的各种细节。 左边是生物神经元，右边是数学模型。 前向传播卷积自然图像有其固有特性，也就是说，图像的一部分的统计特性与其他部分是一样的。这也意味着我们在这一部分学习的特征也能用在另一部分上，所以对于这个图像上的所有位置，我们都能使用同样的学习特征。 更恰当的解释是，当从一个大尺寸图像中随机选取一小块，比如说 8x8 作为样本，并且从这个小块样本中学习到了一些特征，这时我们可以把从这个 8x8 样本中学习到的特征作为探测器，应用到这个图像的任意地方中去。特别是，我们可以用从 8x8 样本中所学习到的特征跟原本的大尺寸图像作卷积，从而对这个大尺寸图像上的任一位置获得一个不同特征的激活值。 下面给出一个具体的例子：假设你已经从一个 96x96 的图像中学习到了它的一个 8x8 的样本所具有的特征，假设这是由有 100 个隐含单元的自编码完成的。为了得到卷积特征，需要对 96x96 的图像的每个 8x8 的小块图像区域都进行卷积运算。也就是说，抽取8x8 的小块区域，并且从起始坐标开始依次标记为（1，1），（1，2），…，一直到（89，89），然后对抽取的区域逐个运行训练过的稀疏自编码来得到特征的激活值。在这个例子里，显然可以得到 100 个集合，每个集合含有 89x89 个卷积特征。 假设给定了 $r \times c$ 的大尺寸图像，将其定义为 xlarge。首先通过从大尺寸图像中抽取的 $a \times b$ 的小尺寸图像样本 $x_{small}$ 训练稀疏自编码，计算 $f = σ(W(1)x_{small} + b(1))$ （σ 是一个 sigmoid 型函数）得到了 k 个特征， 其中 W(1) 和 b(1) 是可视层单元和隐含单元之间的权重和偏差值。对于每一个 $a \times b$ 大小的小图像 $x_s$，计算出对应的值 $f_s = σ(W(1)x_s + b(1))$ ，对这些 fconvolved 值做卷积，就可以得到 $k \times (r - a + 1) \times (c - b + 1)$ 个卷积后的特征的矩阵。 窄卷积 vs 宽卷积在上文中解释卷积运算的时候，忽略了如何使用滤波器的一个小细节。在矩阵的中部使用3x3的滤波器没有问题，在矩阵的边缘该怎么办呢？左上角的元素没有顶部和左侧相邻的元素，该如何滤波呢？解决的办法是采用补零法（zero-padding）。所有落在矩阵范围之外的元素值都默认为0。这样就可以对输入矩阵的每一个元素做滤波了，输出一个同样大小或是更大的矩阵。补零法又被称为是宽卷积，不使用补零的方法则被称为窄卷积。在具体的试验中就是pad字段设置 0 or other 1D的例子如图所示： 窄卷积 vs 宽卷积。滤波器长度为5，输入长度为7。 步长卷积运算的另一个超参数是步长，即每一次滤波器平移的距离。上面所有例子中的步长都是1，相邻两个滤波器有重叠。步长越大，则用到的滤波器越少，输出的值也越少.在实验中使用strike进行控制 池化 pooling卷积神经网络的一个重要概念就是池化层，一般是在卷积层之后。池化层对输入做降采样。常用的池化做法是对每个滤波器的输出求最大值。我们并不需要对整个矩阵都做池化，可以只对某个窗口区间做池化。例如，下图所示的是2x2窗口的最大值池化（在NLP里，我们通常对整个输出做池化，每个滤波器只有一个输出值）： 池化的特点之一就是它输出一个固定大小的矩阵，这对分类问题很有必要。例如，如果你用了1000个滤波器，并对每个输出使用最大池化，那么无论滤波器的尺寸是多大，也无论输入数据的维度如何变化，你都将得到一个1000维的输出。这让你可以应用不同长度的句子和不同大小的滤波器，但总是得到一个相同维度的输出结果，传入下一层的分类器。 池化还能降低输出结果的维度，（理想情况下）却能保留显著的特征。你可以认为每个滤波器都是检测一种特定的特征，例如，检测句子是否包含诸如“not amazing”等否定意思。如果这个短语在句子中的某个位置出现，那么对应位置的滤波器的输出值将会非常大，而在其它位置的输出值非常小。通过采用取最大值的方式，能将某个特征是否出现在句子中的信息保留下来，但是无法确定它究竟在句子的哪个位置出现。这个信息出现的位置真的很重要吗？确实是的，它有点类似于一组n-grams模型的行为。尽管丢失了关于位置的全局信息（在句子中的大致位置），但是滤波器捕捉到的局部信息却被保留下来了，比如“not amazing”和“amazing not”的意思就大相径庭。 在图像识别领域，池化还能提供平移和旋转不变性。若对某个区域做了池化，即使图像平移/旋转几个像素，得到的输出值也基本一样，因为每次最大值运算得到的结果总是一样的 前向现在设节点 $i$ 和节点 $j$ 之间的权值为 $w_{i,j}$ ，节点 $j$ 的阀值为 $b_j$ ，每个节点的输出值为 $x_j$ ，而每个节点的输出值是根据上层所有节点的输出值、当前节点与上一层所有节点的权值和当前节点的阀值还有激活函数来实现的。具体计算方法如下 $$S_j=\sum_{i=0}^{m-1}{w_{i,j}x_i+b_j}$$$$x_j=f\left( S_j \right) $$ 其中 $f$ 为激活函数，一般选取S型函数或者线性函数。正向传递的过程比较简单，按照上述公式计算即可。在BP神经网络中，输入层节点没有阀值。 卷积的前向如下图，卷积层的输入来源于输入层或者pooling层。每一层的多个卷积核大小相同，在这个网络中，使用的卷积核均为 $5\times 5$ 。 如图输入为 $28 \times 28$ 的图像，经过 $5 \times5$ 的卷积之后，得到一个 $(28-5+1)\times (28-5+1) = 24\times 24$ 的map。卷积层2的每个map是不同卷积核在前一层每个map上进行卷积，并将每个对应位置上的值相加然后再加上一个偏置项。 每次用卷积核与map中对应元素相乘，然后移动卷积核进行下一个神经元的计算。如图中矩阵C的第一行第一列的元素2，就是卷积核在输入map左上角时的计算结果。在图中也很容易看到，输入为一个 $4\times 4$ 的map，经过 $2\times 2$ 的卷积核卷积之后，结果为一个 $(4-2+1) \times (4-2+1) = 3\times 3$ 的map。 卷积前向的caffe实现Caffe中卷积的实现十分巧妙，详细可以参考一下这篇论文: https://hal.archives-ouvertes.fr/file/index/docid/112631/filename/p1038112283956.pdf 下面是一张论文中的图片，看这张图片可以很清楚理解。从图中可以看出，卷积之前将输入的多个矩阵和多个卷积核先展开再组合成2个大的矩阵，用展开后的矩阵相乘。 假设我们一次训练16张图片(即batch_size为16)。通过之前的推导，我们知道该层的输入为20个 $12\times 12$ 的特征图，所以bottom的维度 $16\times 20\times 12\times 12$ ，则该层的输出top的维度为 $16\times 50 \times 8\times 8$ 。 后向传播反向梯度在BP神经网络中，误差信号反向传递子过程比较复杂，它是基于 Widrow-Hoff 学习规则的。假设输出层的所有结果为，误差函数如下$$E\left( w,b \right) =\frac{1}{2}\sum_{j=0}^{n-1}{\left( d_j-y_j \right) ^2}$$ 而BP神经网络的主要目的是反复修正权值和阀值，使得误差函数值达到最小。Widrow-Hoff 学习规则是通过沿着相对误差平方和的最速下降方向，连续调整网络的权值和阀值，根据梯度下降法，权值矢量的修正正比于当前位置上 $E(w,b)$ 的梯度，对于第 $j$ 个输出节点有$$\varDelta w\left( i,j \right) =-\eta \frac{\partial E\left( w,b \right)}{\partial w\left( i,j \right)}$$假设我们选择激活函数：$$f\left( x \right) =\frac{A}{1+e^{-\frac{x}{B}}}$$对其进行求导：$$f’\left( x \right) =\frac{Ae^{-\frac{x}{B}}}{B\left( 1+e^{-\frac{x}{B}} \right) ^2}$$$$=\frac{1}{AB}\cdot \frac{A}{1+e^{-\frac{x}{B}}}\cdot \left( A-\frac{A}{1+e^{-\frac{x}{B}}} \right)$$$$=\frac{f\left( x \right) \left[ A-f\left( x \right) \right]}{AB}$$那么接下来针对 $w_{i,j}$ $$ \frac{\partial E\left( w,b \right)}{\partial w_{ij}}=\frac{1}{\partial w_{ij}}\cdot \frac{1}{2}\sum_{j=0}^{n-1}{\left( d_j-y_j \right) ^2} $$ $$=\left( d_j-y_j \right) \cdot \frac{\partial d_j}{\partial w_{ij}}$$ $$=\left( d_j-y_j \right) \cdot f’\left( S_j \right) \frac{\partial S_j}{\partial w_{ij}}$$ $$=\left( d_j-y_j \right) \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB}$$ $$=\left( d_j-y_j \right) \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB}\cdot x_i$$ $$=\delta_{ij}\cdot x_j$$ 其中有 $$\delta_{ij}=\left( d_j-y_j \right) \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB} $$ 同样，对于 $b_j$$$\frac{\partial E\left( w,b \right)}{\partial b_j}=\delta_{ij}$$ 这就是著名的 $\delta$ 学习规则，通过改变神经元之间的连接权值来减少系统实际输出和期望输出的误差，这个规则又叫做Widrow-Hoff学习规则或者纠错学习规则。 上面是对隐含层和输出层之间的权值和输出层的阀值计算调整量，而针对输入层和隐含层和隐含层的阀值调整量的计算更为复杂。假设是输入层第 $k$ 个节点和隐含层第 $i$ 个节点之间的权值，那么有 $$\frac{\partial E\left( w,b \right)}{\partial w_{ki}}=\frac{1}{\partial w_{ki}}\cdot \frac{1}{2}\sum_{j=0}^{n-1}{\left( d_j-y_j \right) ^2}$$$$=\sum_{j=0}^{n-1}{\left( d_j-y_j \right) \cdot f’\left( S_j \right) \cdot \frac{\partial S_j}{\partial w_{kj}}}$$$$=\sum_{j=0}^{n-1}{\left( d_j-y_j \right) \cdot f’\left( S_j \right) \cdot \frac{\partial S_j}{\partial x_i}\cdot \frac{\partial x_i}{\partial S_i}\cdot \frac{\partial S_j}{\partial w_{kj}}}$$$$=\sum_{j=0}^{n-1}{\delta_{ij}\cdot w_{ij}\cdot \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB}}\cdot x_k$$$$=x_k\cdot \sum_{j=0}^{n-1}{\delta_{ij}\cdot w_{ij}\cdot \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB}}$$$$=\delta_{ki}\cdot x_k$$ 其中有 $$\delta_{ki}=\sum_{j=0}^{n-1}{\delta_{ij}\cdot w_{ij}\cdot \frac{f\left( S_j \right) \left[ A-f\left( S_j \right) \right]}{AB}}$$ 梯度下降更新有了上述公式，根据梯度下降法，那么对于隐含层和输出层之间的权值和阀值调整如下$$w_{ij}=w_{ij}-\eta_1\frac{\partial E\left( w,b \right)}{\partial w_{ij}}=w_{ij}-\eta_1\delta_{ij}\cdot x_i$$ $$b_j=b_j-\eta_2\frac{\partial E\left( w,b \right)}{\partial b_j}=b_j-\eta_2\delta_{ij}$$ 而对于输入层和隐含层之间的权值和阀值调整同样有 $$w_{ki}=w_{ki}-\eta_1\frac{\partial E\left( w,b \right)}{\partial w_{ki}}=w_{ki}-\eta_1\delta_{ki}\cdot x_k$$ $$b_i=b_i-\eta_2\frac{\partial E\left( w,b \right)}{\partial b_i}=b_i-\eta_2\delta_{ki}$$ bp的缺陷 容易形成局部极小值而得不到全局最优值。BP神经网络中极小值比较多，所以很容易陷入局部极小值，这就要求对初始权值和阀值有要求，要使得初始权值和阀值随机性足够好，可以多次随机来实现。 训练次数多使得学习效率低，收敛速度慢。 隐含层的选取缺乏理论的指导。 训练时学习新样本有遗忘旧样本的趋势。卷积的后向传播在反向传播过程中，若第x层的a节点通过权值W对x+1层的b节点有贡献，则在反向传播过程中，梯度通过权值W从b节点传播回a节点。不管下面的公式推导，还是后面的卷积神经网络，在反向传播的过程中，都是遵循这样的一个规律。 卷积层的反向传播过程也是如此，我们只需要找出卷积层L中的每个单元和L+1层中的哪些单元相关联即可。我们还用此的图片举例子。在上图中，我们的矩阵A11通过权重B11与C11关联。而A12与2个矩阵C中2个元素相关联，分别是通过权重B12和C11关联，和通过权重B11和C12相关联。矩阵A中其他元素也类似。 那么，我们有没有简单的方法来实现这样的关联呢。答案是有的。可以通过将卷积核旋转180度，再与扩充后的梯度矩阵进行卷积。扩充的过程如下：如果卷积核为 $k\times k$ ，待卷积矩阵为 $n\times n$ ，需要以$n\times n$ 原矩阵为中心扩展到 $(n+2(k-1))\times (n+2(k-1))$ 。具体过程如下：假设D为反向传播到卷积层的梯度矩阵，则D应该与矩阵C的大小相等，在这里为3*3。我们首先需要将它扩充到 $(3+2\times(2-1))\times (3+2\times(2-1)) = 5\times 5$ 大小的矩阵，同时将卷积核B旋转180度：将旋转后的卷积核与扩充后的梯度矩阵进行卷积：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo快速搭建github pages博客]]></title>
      <url>%2F2016%2F11%2F01%2F%E4%BD%BF%E7%94%A8hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAgit%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[github pages简介 Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 https://pages.github.com/ 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。 node.js之hexoNode.js®是一个基于Chrome V8 引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。Node.js 之生态系统是目前最大的开源包管理系统。 hexoHexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上 hexo之NexT主题 一个很好的基于hexo的主题，在NexT主题里有 scheme小主题的概念，非常棒，简约风格。 搭建博客系统 首先下载安装node.js https://nodejs.org/zh-cn/ 下载之后打开node.js command prompt 开始下载hexo 运行如下的命令 123456789101112131415161718$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server#安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。#新建完成后，指定文件夹的目录如下.├── _config.yml├── package.json├── scaffolds├── scripts├── source| ├── _drafts| └── _posts└── themes 这时候使用 1hexo s 就可以打开 localhost: 4000进行访问看到hexo的landspace 就成功了 note：如果你的安装了福新阅读器等一些占用4000端口的程序。就会加载不出来。 可以更改端口： 1hexo s -p 3600 安装成功之后可以绑定自己的gitHub.后面的NexT主题安装部分详细见： http://theme-next.iissnan.com/]]></content>
    </entry>

    
  
  
</search>
