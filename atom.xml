<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Unsky Blog</title>
  <subtitle>Unsky Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-09T11:37:17.495Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>unsky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聚类分析</title>
    <link href="http://yoursite.com/2016/11/09/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/11/09/聚类分析/</id>
    <published>2016-11-09T09:33:59.000Z</published>
    <updated>2016-11-09T11:37:17.495Z</updated>
    
    <content type="html"><![CDATA[<p>聚类分析将数据划分成有意义或有用的组（簇）。<br>聚类分析仅根据在数据中发现的描述对象及其关系的信息，将数据对象分组。其目标是，<br>组内的对象相互之间是相似的，而不同组中的对象是不同的。<br> <a id="more"></a></p>
<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>一个好的聚类方法要能产生高质量的聚类结果——簇，这些簇要具备以下两个特点：</p>
<ol>
<li>高的簇内相似性</li>
<li>低的簇间相似性</li>
</ol>
<p>聚类结果的好坏取决于该聚类方法采用的相似性评估方法以及该方法的具体实现<br>聚类方法的好坏还取决于该方法是否能发现某些还是所有的隐含模式</p>
<p><img src="/images/clutster/1.png" alt=""></p>
<p>聚类可以分为：</p>
<ol>
<li>划分聚类（Partitional Clustering）</li>
<li>层次聚类（Hierarchical Clustering）</li>
<li>互斥（重叠）聚类（exclusive clustering）</li>
<li>非互斥聚类（non-exclusive）</li>
<li>模糊聚类（fuzzy clustering）</li>
<li>完全聚类（complete clustering）</li>
<li>部分聚类（partial clustering）</li>
</ol>
<h2 id="划分聚类"><a href="#划分聚类" class="headerlink" title="划分聚类"></a>划分聚类</h2><p>划分聚类简单地将数据对象集划分成不重叠的子集，使得每个数据对象恰在一个子集。</p>
<p><img src="/images/clutster/2.png" alt=""></p>
<h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><p>层次聚类是嵌套簇的集族，组织成一棵树。<br><img src="/images/clutster/3.png" alt=""></p>
<h2 id="互斥聚类（exclusive）"><a href="#互斥聚类（exclusive）" class="headerlink" title="互斥聚类（exclusive）"></a>互斥聚类（exclusive）</h2><p>每个对象都指派到单个簇.</p>
<h2 id="重叠聚类（overlapping）或非互斥聚类（non-exclusive）"><a href="#重叠聚类（overlapping）或非互斥聚类（non-exclusive）" class="headerlink" title="重叠聚类（overlapping）或非互斥聚类（non-exclusive）"></a>重叠聚类（overlapping）或非互斥聚类（non-exclusive）</h2><p>聚类用来反映一个对象.同时属于多个组（类）这一事实。<br>例如：在大学里，一个人可能既是学生，又是雇员</p>
<h2 id="模糊聚类（Fuzzy-clustering-）"><a href="#模糊聚类（Fuzzy-clustering-）" class="headerlink" title="模糊聚类（Fuzzy clustering ）"></a>模糊聚类（Fuzzy clustering ）</h2><p>每个对象以一个0（绝对不属于）和1（绝对属于）之间的隶属权值属于每个簇。<br>换言之，簇被视为模糊集。</p>
<h2 id="部分聚类（Partial）"><a href="#部分聚类（Partial）" class="headerlink" title="部分聚类（Partial）"></a>部分聚类（Partial）</h2><p>部分聚类中数据集某些对象可能不属于明确定义的组。如：一些对象可能是离群点、噪声。</p>
<h2 id="完全聚类（complete）"><a href="#完全聚类（complete）" class="headerlink" title="完全聚类（complete）"></a>完全聚类（complete）</h2><p>完全聚类将每个对象指派到一个簇。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="簇的分类"><a href="#簇的分类" class="headerlink" title="簇的分类"></a>簇的分类</h2><p>簇是同一性状物体的集合<br>按照性状的分类不同可以将簇分为</p>
<ol>
<li>明显分离的</li>
</ol>
<p>每个点到同簇中任一点的距离比到不同簇中所有点的距离更近。</p>
<ol>
<li>基于原型的</li>
</ol>
<p>每个对象到定义该簇的原型的距离比到其他簇的原型的距离更近。<br>对于具有连续属性的数据，簇的原型通常是质心，即簇中所有点的平均值。<br>当质心没有意义时，原型通常是中心点，即簇中最有代表性的点。</p>
<p>基于中心的（ Center-Based）的簇：<br>每个点到其簇中心的距离比到任何其他簇中心的距离更近。</p>
<ol>
<li>基于图的</li>
</ol>
<p>如果数据用图表示，其中节点是对象，而边代表对象之间的联系。</p>
<p>簇可以定义为连通分支（connected component）：互相连通但不与组外对象连通的对象组。</p>
<p>基于近邻的（ Contiguity-Based）：其中两个对象是相连的，仅当它们的距离在指定的范围内。这意味着，每个对象到该簇某个对象的距离比到不同簇中任意点的距离更近。</p>
<ol>
<li>基于密度的</li>
</ol>
<p>簇是对象的稠密区域，被低密度的区域环绕。</p>
<ol>
<li><p>概念簇<br>可以把簇定义为有某种共同性质的对象的集合。<br>例如：基于中心的聚类。还有一些簇的共同性质需要更复杂的算法才能识别出来。</p>
<p>本系列文章将探究各个聚类方式之间的区别</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚类分析将数据划分成有意义或有用的组（簇）。&lt;br&gt;聚类分析仅根据在数据中发现的描述对象及其关系的信息，将数据对象分组。其目标是，&lt;br&gt;组内的对象相互之间是相似的，而不同组中的对象是不同的。&lt;br&gt;
    
    </summary>
    
      <category term="聚类分析" scheme="http://yoursite.com/categories/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="聚类分析" scheme="http://yoursite.com/tags/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>互斥聚类-k-means聚类</title>
    <link href="http://yoursite.com/2016/11/09/k-means%E8%81%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/11/09/k-means聚类/</id>
    <published>2016-11-09T08:56:52.000Z</published>
    <updated>2016-11-10T03:05:33.235Z</updated>
    
    <content type="html"><![CDATA[<p> 在数据挖掘中，K-Means算法是一种cluster analysis的算法， 其主要是来计算数据聚集算法，主要通过不断地取离种子点最近均值的算法。<br> <a id="more"></a></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们用肉眼可以看出来有四个点群，但是我们怎么通过计算机程序找出这几个点群来呢？</p>
<p>于是就出现了我们的K-Means算法。<br><img src="/images/kmeans/1.png" alt=""><br>算法概要如下图所示：<br><img src="/images/kmeans/2.png" alt=""><br>从上图中，我们可以看到，A，B，C，D，E是五个在图中点。而灰色的点是我们的种子点，也就是我们用来找点群的点。有两个种子点，所以K=2。</p>
<p>然后，K-Means的算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. 随机在图中取K（这里K=2）个种子点</div><div class="line"></div><div class="line">2. 然后对图中的所有点求到这K个种子点的距离，假如点Pi离种子点Si最近，</div><div class="line">那么Pi属于Si点群。</div><div class="line">（上图中，我们可以看到A，B属于上面的种子点，C，D，E属于下面中部的种子点）</div><div class="line">3. 我们要移动种子点到属于他的“点群”的中心。（见图上的第三步）</div><div class="line">然后重复第2）和第3）步直到，种子点没有移动（我们可以看到图中的第四步上面的种子点聚合了A，B，C，下面的种子点聚合了D，E）。</div></pre></td></tr></table></figure>
<p>使用公式可以表示为：<br>$$\varUpsilon =\sum_{k=1}^K{\sum_{i=1}^L{dist\left( x_i-u_k \right)}}$$<br>而$dist$距离函数可以分为：</p>
<ol>
<li>Minkowski Distance（闵可夫斯基距离）<br>$$<br>d_{i,j}=\sqrt[\lambda]{\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}^{\lambda}}<br>$$<br>$\lambda$ 可以随意取值，可以是负数，也可以是正数，或是无穷大</li>
<li>Euclidean Distance(欧拉距离)</li>
</ol>
<p>$$<br>d_{i,j}=\sqrt[]{\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}^2}<br>$$<br>其形式为 Minkowski Distance 为 $\lambda$=2时候的特殊形式。</p>
<ol>
<li>CityBlock Distance （CB距离）<br>$$<br>d_{i,j}=\sum_{k=1}^n{|x_{i,k}-x_{j,k}|}<br>$$<br>也就是第一个公式 $\lambda$=1的情况。</li>
</ol>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>在模拟k-means的实验中我们使用深度学习网络vgg16在一个层的feature maps 来进行模拟实验，用来验证聚类效果，输入图片为一个行人。我们使用vgg16 conv1-2产生的feature maps进行实验。假设我们产生的feature maps 为 $\psi \in R^{m\times n\times k}$ ,其中 $m\times n$ 为feature大小, k为map的个数。首先每个feature进行向量化，从而将其转化为 $\psi \in R^{m* n\times k}$ 。使用k-means对一个层的feature maps进行聚类，并可视化效果。本实验中使用欧式距离。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li>实验使用vlfeat工具包<br>下载地址： <a href="https://github.com/unsky/vlfeat" target="_blank" rel="external">https://github.com/unsky/vlfeat</a></li>
<li>在vlfeat\toolbox中使用vl_setup启动工具包</li>
</ol>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>假设feature maps已经存在于 res1.mat 中<br>运行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">load(&apos;res1.mat&apos;);</div><div class="line">a=res(23).x;</div><div class="line">[w,e,r]=size(a);</div><div class="line"></div><div class="line">a=reshape(a,w*e,r);</div><div class="line"> [C, A] = vl_kmeans(a, 10) ;</div><div class="line"> for i=1:10,</div><div class="line"> fea=C(:,i);</div><div class="line"> fea=reshape(fea,w,e);</div><div class="line">  n = mapminmax(fea, 0, 1);</div><div class="line"> subplot(2,5,i);</div><div class="line"> imshow(n);</div><div class="line"> hold on;</div><div class="line"> end</div></pre></td></tr></table></figure></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ol>
<li>原始64个feature的可视化：<br><img src="/images/kmeans/3.png" alt=""></li>
<li>k-means （k=10）<br><img src="/images/kmeans/4.png" alt=""></li>
</ol>
<p>k=5<br><img src="/images/kmeans/5.png" alt=""></p>
<p>k=1<br><img src="/images/kmeans/6.png" alt=""></p>
<h1 id="k-means-优缺点"><a href="#k-means-优缺点" class="headerlink" title="k-means 优缺点"></a>k-means 优缺点</h1><p> 优点：</p>
<ol>
<li>算法简单</li>
<li>适用于球形簇</li>
<li>二分k均值等变种算法运行良好，不受初始化问题的影响。</li>
</ol>
<p>缺点：</p>
<ol>
<li>不能处理非球形簇、不同尺寸和不同密度的簇</li>
<li>对离群点、噪声敏感</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在数据挖掘中，K-Means算法是一种cluster analysis的算法， 其主要是来计算数据聚集算法，主要通过不断地取离种子点最近均值的算法。&lt;br&gt;
    
    </summary>
    
      <category term="聚类分析" scheme="http://yoursite.com/categories/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="k-means" scheme="http://yoursite.com/tags/k-means/"/>
    
      <category term="聚类" scheme="http://yoursite.com/tags/%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>手把手将atom打造成c++/c编程利器</title>
    <link href="http://yoursite.com/2016/11/08/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B0%86atom%E6%89%93%E9%80%A0%E6%88%90c-c%E7%BC%96%E7%A8%8B%E5%88%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2016/11/08/手把手将atom打造成c-c编程利器/</id>
    <published>2016-11-08T02:31:28.000Z</published>
    <updated>2016-11-10T03:04:45.918Z</updated>
    
    <content type="html"><![CDATA[<p>Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。多数的延伸包皆为开放源代码授权，并由社区建置与维护。Atm基于Chromium并使用CoffeeScript撰写。Atom也可当作IDE使用。<br> <a id="more"></a></p>
<h1 id="安装atom"><a href="#安装atom" class="headerlink" title="安装atom"></a>安装atom</h1><p> 原则自己的平台安装，本文所有操作均在 win10中进行。</p>
<p> 官方下载地址：<a href="https://atom.io/" target="_blank" rel="external">https://atom.io/</a></p>
<p> 安装之后进入欢迎界面<br> <img src="/images/atomle/1.png" alt=""><br>原始的atom已经安装了一些插件。但是我们需要将其打造成一个c/c++ IDE.</p>
<h1 id="编译和调试插件-gpp-compliler"><a href="#编译和调试插件-gpp-compliler" class="headerlink" title="编译和调试插件 gpp-compliler"></a>编译和调试插件 gpp-compliler</h1><p>编译和调试是ide的基本功能不可或缺。</p>
<p>gpp-compliler 安装依赖于 MinGW 下载地址：<a href="http://www.mingw.org/" target="_blank" rel="external">http://www.mingw.org/</a></p>
<p>MinGW(Minimalist GNU For Windows)是个精简的Windows平台C/C++、ADA及Fortran编译器，相比Cygwin而言，体积要小很多，使用较为方便。</p>
<h2 id="运行刚刚下载的安装程序"><a href="#运行刚刚下载的安装程序" class="headerlink" title="运行刚刚下载的安装程序"></a>运行刚刚下载的安装程序</h2><p> <img src="/images/atomle/2.png" alt=""><br> 安装到D:\MinGW，点”Continue”。之后在桌面会形成一个安装器：<br>  <img src="/images/atomle/3.png" alt=""><br>  运行</p>
<h2 id="选择安装组件"><a href="#选择安装组件" class="headerlink" title="选择安装组件"></a>选择安装组件</h2><p>  运行安装程序。<img src="/images/atomle/4.png" alt="">  选择需要安装的组件，右键选择Mark for Installation,之后选择Installation -&gt; Apply Changes。</p>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>  这里重点要提到的是GCC组件的安装，如图所示<br>      <img src="/images/atomle/5.png" alt=""><br>      先选择左边的”MinGW Base System”选项，之后再右边找到mingw-gcc。最好选择bin,dev和lic三个组件进行安装。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p> 设置MinGW环境变量<br>鼠标右键“我的电脑”-&gt;“属性”，选择“高级”选项卡下的“环境变量”，在系统变量里点“新建”，之后填写MinGW的安装路径，如下：<br>      <img src="/images/atomle/6.png" alt=""><br>      之后找到Path，在最前面添加下面这段声明，之后点击确定。安装完成后，在MinGW\bin的目录下，会有一个名为gcc.exe的可执行文件。在 <code>cmd</code> 运行  <code>gcc -v</code>会出现版本信息，如果显示，则安装成功。回到atom,新建一个cpp文件，代码中我们加个错误</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">int main()&#123;</div><div class="line">    int aaa;</div><div class="line">    cin&gt;&gt;aaa;</div><div class="line">aa</div><div class="line">  cout&lt;&lt;aaa&lt;&lt;endl;</div><div class="line"></div><div class="line">        return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>  运行 <code>F5</code><br>    <img src="/images/atomle/7.png" alt=""><br>    错误提示在右上角。<br>    将代码修改正确<br>        <img src="/images/atomle/8.png" alt=""><br>        显示控制台结果.</p>
<h1 id="代码错误检测-linter-gcc"><a href="#代码错误检测-linter-gcc" class="headerlink" title="代码错误检测 linter-gcc"></a>代码错误检测 linter-gcc</h1><p>linter-gcc 安装依赖于linter 首先安装linter包。同时还依赖于 gcc 在上一步我们已经安装了gcc并且已经加入了路径，如果没有请自行安装。</p>
<p>只需在 linter-gcc的设置里面<br> <img src="/images/atomle/9.png" alt=""><br><code>F5</code> 运行一段代码错误代码，可以显示：<br><img src="/images/atomle/10.png" alt=""><br>  到这里 atom已经可以完成我们编译所需的环境，剩下的可以进一步就行优化推荐一些优秀的插件</p>
<h1 id="高亮选择-highlight-selected"><a href="#高亮选择-highlight-selected" class="headerlink" title="高亮选择 highlight-selected"></a>高亮选择 highlight-selected</h1><p>可以高亮选择的关键字<br>    <img src="/images/atomle/11.png" alt=""></p>
<h1 id="自动美化代码-atom-beautiful"><a href="#自动美化代码-atom-beautiful" class="headerlink" title="自动美化代码 atom-beautiful"></a>自动美化代码 atom-beautiful</h1><h1 id="minimap"><a href="#minimap" class="headerlink" title="minimap"></a>minimap</h1><p>和submit一种风格的快速浏览窗口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。多数的延伸包皆为开放源代码授权，并由社区建置与维护。Atm基于Chromium并使用CoffeeScript撰写。Atom也可当作IDE使用。&lt;br&gt;
    
    </summary>
    
      <category term="环境搭建" scheme="http://yoursite.com/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="atom" scheme="http://yoursite.com/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络学习历程</title>
    <link href="http://yoursite.com/2016/11/02/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/11/02/卷积神经网络学习历程/</id>
    <published>2016-11-01T16:10:30.000Z</published>
    <updated>2016-11-10T03:01:47.962Z</updated>
    
    <content type="html"><![CDATA[<p>  神经网络算法领域最初是被对生物神经系统建模这一目标启发，但随后与其分道扬镳，成为一个工程问题，并在机器学习领域取得良好效果。然而，讨论将还是从对生物系统的一个高层次的简略描述开始，因为神经网络毕竟是从这里得到了启发.</p>
<h1 id="神经元建模"><a href="#神经元建模" class="headerlink" title="神经元建模"></a>神经元建模</h1><p>  大脑的基本计算单位是神经元（neuron）。人类的神经系统中大约有860亿个神经元，它们被大约10^14-10^15个突触（synapses）连接起来。下面图表的左边展示了一个生物学的神经元，右边展示了一个常用的数学模型。每个神经元都从它的树突获得输入信号，然后沿着它唯一的轴突（axon）产生输出信号。轴突在末端会逐渐分枝，通过突触和其他神经元的树突相连。</p>
<p>  在神经元的计算模型中，沿着轴突传播的信号（比如 $x_0$ ）将基于突触的突触强（比如 $w_0$ ），与其他神经元的树突进行乘法交互（比如$w_0x_0$）。其观点是，突触的强度（也就是权重），是可学习的且可以控制一个神经元对于另一个神经元的影响强度（还可以控制影响方向：使其兴奋（正权重）或使其抑制（负权重））。在基本模型中，树突将信号传递到细胞体，信号在细胞体中相加。如果最终之和高于某个阈值，那么神经元将会激活，向其轴突输出一个峰值信号。在计算模型中，我们假设峰值信号的准确时间点不重要，是激活信号的频率在交流信息。基于这个速率编码的观点，将神经元的激活率建模为激活函数（activation function）f，它表达了轴突上激活信号的频率。由于历史原因，激活函数常常选择使用sigmoid函数 $\sigma$，该函数输入实数值（求和后的信号强度），然后将输入值压缩到0-1之间。在本节后面部分会看到这些激活函数的各种细节。</p>
<p>  <img src="/images/cnn/1.png" alt=""><br>  左边是生物神经元，右边是数学模型。</p>
<h1 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h1><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>自然图像有其固有特性，也就是说，图像的一部分的统计特性与其他部分是一样的。这也意味着我们在这一部分学习的特征也能用在另一部分上，所以对于这个图像上的所有位置，我们都能使用同样的学习特征。</p>
<p>更恰当的解释是，当从一个大尺寸图像中随机选取一小块，比如说 8x8 作为样本，并且从这个小块样本中学习到了一些特征，这时我们可以把从这个 8x8 样本中学习到的特征作为探测器，应用到这个图像的任意地方中去。特别是，我们可以用从 8x8 样本中所学习到的特征跟原本的大尺寸图像作卷积，从而对这个大尺寸图像上的任一位置获得一个不同特征的激活值。</p>
<p>下面给出一个具体的例子：假设你已经从一个 96x96 的图像中学习到了它的一个 8x8 的样本所具有的特征，假设这是由有 100 个隐含单元的自编码完成的。为了得到卷积特征，需要对 96x96 的图像的每个 8x8 的小块图像区域都进行卷积运算。也就是说，抽取8x8 的小块区域，并且从起始坐标开始依次标记为（1，1），（1，2），…，一直到（89，89），然后对抽取的区域逐个运行训练过的稀疏自编码来得到特征的激活值。在这个例子里，显然可以得到 100 个集合，每个集合含有 89x89 个卷积特征。<br>  <img src="/images/cnn/2.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  神经网络算法领域最初是被对生物神经系统建模这一目标启发，但随后与其分道扬镳，成为一个工程问题，并在机器学习领域取得良好效果。然而，讨论将还是从对生物系统的一个高层次的简略描述开始，因为神经网络毕竟是从这里得到了启发.&lt;/p&gt;
&lt;h1 id=&quot;神经元建模&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="卷积深度网络全剖析" scheme="http://yoursite.com/categories/%E5%8D%B7%E7%A7%AF%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E5%85%A8%E5%89%96%E6%9E%90/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="卷积" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo快速搭建github pages博客</title>
    <link href="http://yoursite.com/2016/11/01/%E4%BD%BF%E7%94%A8hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAgit%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/11/01/使用hexo快速搭建git博客/</id>
    <published>2016-11-01T15:40:13.000Z</published>
    <updated>2016-11-09T10:47:45.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github-pages简介"><a href="#github-pages简介" class="headerlink" title=" github pages简介"></a> github pages简介</h2><p><img src="/images/gitblog/githubpages.png" alt=""></p>
<p>Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 <a href="https://pages.github.com/" target="_blank" rel="external">https://pages.github.com/</a> 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。<br><a id="more"></a></p>
<h2 id="node-js之hexo"><a href="#node-js之hexo" class="headerlink" title=" node.js之hexo"></a> node.js之hexo</h2><p>Node.js®是一个基于Chrome V8 引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。Node.js 之生态系统是目前最大的开源包管理系统。</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p><img src="/images/gitblog/hexo.png" alt=""><br>Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。</p>
<p>hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上</p>
<h2 id="hexo之NexT主题"><a href="#hexo之NexT主题" class="headerlink" title=" hexo之NexT主题"></a> hexo之NexT主题</h2><p> 一个很好的基于hexo的主题，在NexT主题里有 scheme小主题的概念，非常棒，简约风格。<br> <img src="/images/gitblog/next.png" alt=""></p>
<h2 id="搭建博客系统"><a href="#搭建博客系统" class="headerlink" title=" 搭建博客系统"></a> 搭建博客系统</h2><p> 首先下载安装node.js <a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">https://nodejs.org/zh-cn/</a></p>
<p>  下载之后打开node.js command prompt<br>  开始下载hexo<br>  运行如下的命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-cli -g</div><div class="line">$ hexo init blog</div><div class="line">$ cd blog</div><div class="line">$ npm install</div><div class="line">$ hexo server</div><div class="line"></div><div class="line">#安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</div><div class="line"></div><div class="line">#新建完成后，指定文件夹的目录如下</div><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── scripts</div><div class="line">├── source</div><div class="line">|      ├── _drafts</div><div class="line">|      └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure>
<p>  这时候使用<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure></p>
<p>  就可以打开 localhost: 4000进行访问看到hexo的landspace 就成功了</p>
<p>note：<br><code>如果你的安装了福新阅读器等一些占用4000端口的程序。就会加载不出来。</code></p>
<p>可以更改端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s -p 3600</div></pre></td></tr></table></figure>
<p>安装成功之后可以绑定自己的gitHub.<br>后面的NexT主题安装部分详细见：</p>
<p><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;github-pages简介&quot;&gt;&lt;a href=&quot;#github-pages简介&quot; class=&quot;headerlink&quot; title=&quot; github pages简介&quot;&gt;&lt;/a&gt; github pages简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/gitblog/githubpages.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制，还可以绑定自己的域名。在 &lt;a href=&quot;https://pages.github.com/&quot;&gt;https://pages.github.com/&lt;/a&gt; 首页上可以看到很多用 Github Pages 托管的网站，很漂亮。另外很多非常著名的公司和项目也都用这种方式来搭建网站，如微软和 twitter 的网站，还有 谷歌的 Material Design 图标 网站。&lt;br&gt;
    
    </summary>
    
      <category term="独立博客搭建" scheme="http://yoursite.com/categories/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
